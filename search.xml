<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Basic Usage</title>
    <url>/2021/10/04/Basic-Usage/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“我2D天下无敌了！”</font></center>
<span id="more"></span>
</blockquote>
<h2 id="已知两种二叉树的遍历方式求另一种遍历"><a href="#已知两种二叉树的遍历方式求另一种遍历" class="headerlink" title="已知两种二叉树的遍历方式求另一种遍历"></a>已知两种二叉树的遍历方式求另一种遍历</h2><ul>
<li>已知后序遍历以及中序遍历输出程序遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"><span class="keyword">int</span> l[N];</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="comment">// const ull base=2333333;</span></span><br><span class="line"><span class="comment">// const ull mod=999999998;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ull base=13331;</span></span><br><span class="line"><span class="comment">// const ull mod=91815541;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rtpos,<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st&gt;ed) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=st;i&lt;=ed;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(last[i]==pre[rtpos]) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;&quot;rt: &quot;&lt;&lt;rtpos&lt;&lt;&quot;&quot;&lt;&lt;l[rtpos]&lt;&lt;&quot; &quot;&lt;&lt;r[rtpos]&lt;&lt;endl;</span></span><br><span class="line">	l[rtpos]=<span class="built_in">build</span>(rtpos-(ed-i)<span class="number">-1</span>,st,i<span class="number">-1</span>);</span><br><span class="line">	r[rtpos]=<span class="built_in">build</span>(rtpos<span class="number">-1</span>,i+<span class="number">1</span>,ed);</span><br><span class="line">	<span class="keyword">return</span> rtpos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;pre[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;last[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(n,<span class="number">1</span>,n);</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(n);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="comment">//	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		cout&lt;&lt;pre[l[i]]&lt;&lt;&quot; &quot;&lt;&lt;pre[r[i]]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> top=q.<span class="built_in">front</span>();</span><br><span class="line">		<span class="comment">//		cout&lt;&lt;top&lt;&lt;endl;</span></span><br><span class="line">		ans.<span class="built_in">push_back</span>(top);</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(l[top]) q.<span class="built_in">push</span>(l[top]);</span><br><span class="line">		<span class="keyword">if</span>(r[top]) q.<span class="built_in">push</span>(r[top]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;pre[ans[i]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;pre[ans.<span class="built_in">back</span>()] &lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-n-m-找到从n个数中取m个数的所有方案"><a href="#C-n-m-找到从n个数中取m个数的所有方案" class="headerlink" title="$C_n^m$ 找到从n个数中取m个数的所有方案"></a>$C_n^m$ 找到从n个数中取m个数的所有方案</h2><ul>
<li>方法：数组中前n-m个数设置为0，后m个数设置为1，随后调用next_permutation()方法即可得到所有排列方案，此时数组中为1的位置即为选择的m个数。</li>
<li>注意：如果元素集并不是连续的数，那么通过map建立映射关系同样也能选出m个数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从12个数中选择5个数</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++) a[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">12</span>;i++) a[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==<span class="number">1</span>) cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a+<span class="number">1</span>,a+<span class="number">13</span>));</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;cnt: &quot;</span>&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li>priority_queue&lt; type, container, function&gt;</li>
<li>type 类型</li>
<li>container：实现优先队列的底层容器（缺省），对于container，要求必须是数组形式实现的容器，例如vector、deque，而不能使list。</li>
<li>function：元素之间的比较方式（缺省）,头文件<functional>中，包含less<int>和greater<int></int></int></functional></li>
<li>在STL中，默认情况下（不加后面两个参数）是以vector为容器，以 operator&lt; 为比较方式，所以在只使用第一个参数时，优先队列默认是一个最大堆，每次输出的堆顶元素是此时堆中的最大元素。</li>
<li>大顶堆  priority_queue&lt;int,vector<int>,less<int> &gt; big_heap;   </int></int></li>
<li>小顶堆  priority_queue&lt;int,vector<int>,greater<int> &gt; small_heap; </int></int></li>
<li>自构建比较函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, cmp &gt; q;</span><br></pre></td></tr></table></figure>
<h2 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h2></li>
<li>单个读入字符比直接读入数字快（原理）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于二进制的函数——-builtin-函数"><a href="#关于二进制的函数——-builtin-函数" class="headerlink" title="关于二进制的函数——__builtin_函数"></a>关于二进制的函数——__builtin_函数</h2>  __builtin_popcount(n)：返回n的二进制中1的个数<br>  __builtin_ffs(n)：返回n的最后一位1的是从后向前第几位<br>  __builtin_clz(n)：返回n前导0的个数，对0未定义<br>  __builtin_ctz(n)：返回n后面的0的个数，对0未定义<br>  他们本来的类型都是unsigned int<br>  改成usigned long 加l 例__builtin_clzl<br>  改成usigned long long 加ll 例__builtin_clzll</li>
</ul>
<h2 id="vector的用法"><a href="#vector的用法" class="headerlink" title="vector的用法"></a>vector的用法</h2><p>当题目给定的数据量不确定时又害怕空间超限，一定要想到用vector来控制空间。以下两个函数可以很好的配合然后精确的控制好程序占用的空间。</p>
<ul>
<li>resize(n,m): 将容器的容量改为n，可以赋初值m，但是只会对新开出的空间赋值，原来已经存在的空间中的值不会改变。</li>
<li>clear(): 将容器清空，同时也会把所有的空间回收。</li>
<li>动态开辟二维空间（n*m的空间）：vector&lt;vector<int>&gt; c(n,vector<int>(m));</int></int></li>
</ul>
<h2 id="使用map的小技巧"><a href="#使用map的小技巧" class="headerlink" title="使用map的小技巧"></a>使用map的小技巧</h2><ul>
<li>前言：没办法，最近写题目时在用到map时总感觉对于map的用法不够熟悉，map中总是莫名其妙出现不知道哪里出现的不明生物，就好像map脱离了我的控制一般，因此在这里几下犯下的一些虽然简单但是不容易察觉的错误。</li>
<li>map中的数据查找：由于map中所有元素对应的值都初始化为0，所以一般会向用用map[x]==0?检查x是否在map中，但实际上经过这样一步操作之后会将x也添加进入map中，因此这样的做法是不可取的。正确的做法应该是调用map的查找函数find()，找到则返回该元素的迭代器，否则返回map.end()。</li>
<li>map中元素的更改：切忌在使用map时边访问map中的元素边修改map中元素，这样可能导致过程不可控，如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unorsered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : mp)<span class="comment">//在遍历的过程中就有元素添加进来，这样可能会导致错误的遍历过程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(it==<span class="number">10</span>) mp[t*<span class="number">10</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//vextor&lt;&gt; 的比那里同样也不要这么做</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(j+<span class="number">1</span>);<span class="comment">//由于新增了元素，导致v.size()的值不断变化，从而导致了错误的程序走向</span></span><br><span class="line">                     <span class="comment">//正确的做法是用另一个变量tmp存储下之前的容器大小：int tmp=v.size()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="容器（vector，map，set）通过array实现存储n元组"><a href="#容器（vector，map，set）通过array实现存储n元组" class="headerlink" title="容器（vector，map，set）通过array实现存储n元组"></a>容器（vector，map，set）通过array实现存储n元组</h3><ul>
<li>array模板类的声明<br>  template &lt;class T，size_t N&gt; class array;<br>  array模板类中T为包含元素的类型（std::array::value_type），N为元素个数。</li>
<li>vector实现三元组示例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AI array<span class="meta-string">&lt;int,3&gt;</span></span></span><br><span class="line">set&lt;AI&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AI a3=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	s.<span class="built_in">insert</span>(a3);</span><br><span class="line">    <span class="comment">//s.insert(&#123;1,2,3&#125;)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;it[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	AI tmp=&#123;&#125;;</span><br><span class="line">	tmp[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">	tmp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	tmp[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">find</span>(tmp)!=s.<span class="built_in">end</span>()) cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    </p>
<h2 id="bitset用法"><a href="#bitset用法" class="headerlink" title="bitset用法"></a>bitset用法</h2><ul>
<li>定义：bitset每个位置只占1bit，一般用于优化算法复杂度，能将复杂度o() -&gt; o()/32|64。</li>
<li>初始化：用字符串（bitset&lt;23&gt; bit (string(“11101001”))）或整数初始化均可（bitset&lt;23&gt; bit = 233，整数即转为对应的二进制数。</li>
<li><pre><code>常用操作：支持各种位运算以及以下函数用法
  bit.size()       返回大小（位数）
  bit.count()     返回1的个数
  bit.any()       返回是否有1
  bit.none()      返回是否没有1
  bit.set()       全都变成1
  bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） 
  bit.set(p, x)   将第p + 1位变成x
  bit.reset()     全都变成0
  bit.reset(p)    将第p + 1位变成0
  bit.flip()      全都取反
  bit.flip(p)     将第p + 1位取反
  bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错
  bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错
  bit.to_string() 返回它转换为string的结果
  bit.test(x)      测试是否设置了第x位，返回测试结果（1/0）
</code></pre>
</li>
</ul>
<h2 id="手写hash-map"><a href="#手写hash-map" class="headerlink" title="手写hash_map"></a>手写hash_map</h2><ul>
<li>比STL中的unordered_map稍快一些，可以避免某些卡常。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsz=<span class="number">4e6</span>+<span class="number">9</span>;<span class="comment">//@素数表@:1e7+19,2e7+3,3e7+23</span></span><br><span class="line"><span class="comment">//1e6+3,2e6+3,3e6+7,4e6+9,1e5+3,2e5+3,3e5+7,4e5+9</span></span><br><span class="line"><span class="comment">//@要保证取值的操作次数小于maxsz,maxsz最好为素数@</span></span><br><span class="line"><span class="comment">//@count操作不增加新节点@</span></span><br><span class="line"><span class="comment">//const ull base=2333333;</span></span><br><span class="line"><span class="comment">//#define mod 999999998</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const ull base=13331;</span></span><br><span class="line"><span class="comment">//#define mod 91815541</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ull u;<span class="keyword">int</span> v,next;&#125;e[maxsz&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[maxsz],nume,numk,id[maxsz];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(ull u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hs=u%maxsz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[hs];i;i=e[i].next)</span><br><span class="line">        <span class="keyword">if</span>(e[i].u==u) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](ull u)&#123;</span><br><span class="line">    <span class="keyword">int</span> hs=u%maxsz;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[hs];i;i=e[i].next)</span><br><span class="line">      <span class="keyword">if</span>(e[i].u==u) <span class="keyword">return</span> e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!head[hs])id[++numk]=hs;</span><br><span class="line">    <span class="keyword">return</span> e[++nume]=(node)&#123;u,<span class="number">0</span>,head[hs]&#125;,head[hs]=nume,e[nume].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=numk;i++) head[id[i]]=<span class="number">0</span>;</span><br><span class="line">    numk=nume=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四舍五入保留任意位小数小数"><a href="#四舍五入保留任意位小数小数" class="headerlink" title="四舍五入保留任意位小数小数"></a>四舍五入保留任意位小数小数</h2><p>在保留的位数后一位加上5，在将小数点移至保留的位数后在取整，后将小数点移回即可。<br>四舍五入：（b为double类型）<br>    保留整数 int a = b+0.5;</p>
<pre><code>保留一位小数  int a=(b+0.05)*10;

double c=(double)a/10;

保留二位小数  int a=(b+0.005)*100;

double c=(double)a/100;
</code></pre>
<p>（上面的方法仅适用于正数。）</p>
<h2 id="c-字符串与整型的相互转化"><a href="#c-字符串与整型的相互转化" class="headerlink" title="c++字符串与整型的相互转化"></a>c++字符串与整型的相互转化</h2><ul>
<li>字符串转整形（atoi（ascii to int）函数）<br>int atoi(const char* str) ;<br>转换string类型时应与c_str()函数配合使用，c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同。这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。<br>string的转换如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string  s;</span><br><span class="line"><span class="keyword">int</span> res=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></li>
<li>整形转字符串<br>直接调用to_string(int/double x)函数即可</li>
</ul>
<h2 id="大数取模优化（快速模）"><a href="#大数取模优化（快速模）" class="headerlink" title="大数取模优化（快速模）"></a>大数取模优化（快速模）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fastmod</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> u64 = <span class="keyword">uint64_t</span>;</span><br><span class="line">    <span class="keyword">using</span> u128 = <span class="keyword">__uint128_t</span>;</span><br><span class="line">    <span class="keyword">int</span> f, l; u64 m, d;</span><br><span class="line">    <span class="built_in">fastmod</span>(u64 d): <span class="built_in">d</span>(d) &#123;</span><br><span class="line">        l = <span class="number">64</span> - __builtin_clzll(d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> u128 one = <span class="number">1</span>;</span><br><span class="line">        u128 M = ((one &lt;&lt; (<span class="number">64</span> + l)) + (one &lt;&lt; l)) / d;</span><br><span class="line">        <span class="keyword">if</span>(M &lt; (one &lt;&lt; <span class="number">64</span>)) f = <span class="number">1</span>, m = M;</span><br><span class="line">        <span class="keyword">else</span> f = <span class="number">0</span>, m = M - (one &lt;&lt; <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> u64 <span class="keyword">operator</span>/(u64 n, <span class="keyword">const</span> fastmod &amp;m) &#123; <span class="comment">// get n / d</span></span><br><span class="line">        <span class="keyword">if</span> (m.f) <span class="keyword">return</span> <span class="built_in">u128</span>(n) * m.m &gt;&gt; <span class="number">64</span> &gt;&gt; m.l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            u64 t = <span class="built_in">u128</span>(n) * m.m &gt;&gt; <span class="number">64</span>;</span><br><span class="line">            <span class="keyword">return</span> (((n - t) &gt;&gt; <span class="number">1</span>) + t) &gt;&gt; (m.l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> u64 <span class="keyword">operator</span>%(u64 n, <span class="keyword">const</span> fastmod &amp;m) &#123; <span class="comment">// get n % d</span></span><br><span class="line">        <span class="keyword">return</span> n - n / m * m.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map实现多元组对应一元组"><a href="#unordered-map实现多元组对应一元组" class="headerlink" title="unordered_map实现多元组对应一元组"></a>unordered_map实现多元组对应一元组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">unordered_map&lt;ll,unordered_map&lt;ll,ll&gt; &gt; mp;<span class="comment">//实现二元组对一元组 mp[a][b]=c;</span></span><br><span class="line">unordered_map&lt;ll,unordered_map&lt;ll,unordered_map&lt;ll,ll&gt;&gt; &gt; mp;<span class="comment">//实现三元组对一元组 mp[a][b][c]=d;</span></span><br><span class="line"><span class="comment">//......依此类推</span></span><br></pre></td></tr></table></figure>


<h2 id="ordered-set"><a href="#ordered-set" class="headerlink" title="ordered_set"></a>ordered_set</h2><p>虽说和stl中的set十分相像，但其实和set不是一个东西，且不能直接调用，使用之前需要自定义。</p>
<ul>
<li> ordered_set可以使用的函数和set一样，包括size()、insert()等等，且底层原理也是红黑树，可通过自定义函数实现顺序或逆序排序，但是不会自动去重。</li>
<li> ordered_set有一个独有的函数order_of_key(x)，可以找到集合中比x小的元素个数，反之，若是找比x大的元素个数，即用总元素个数-比x小的元素个数-x的个数。<br><a href="https://codeforces.com/contest/1579/problem/E2">CF - E2</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/trie_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">typedef</span> tree&lt;<span class="keyword">int</span>,null_type,less_equal&lt;<span class="keyword">int</span>&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; ordered_set;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//greater_equal&lt;int&gt; 为排序方式，即从大到小排序，less_equal为从小到大排序</span></span><br><span class="line">ordered_set s;<span class="comment">//有序、不去重</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		s.<span class="built_in">clear</span>();</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">				mp[a[i]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t1=s.<span class="built_in">order_of_key</span>(a[i]);</span><br><span class="line">				<span class="keyword">int</span> t2=s.<span class="built_in">size</span>()-mp[a[i]]-t1;</span><br><span class="line">				<span class="comment">//cout&lt;&lt;&quot;t1: &quot;&lt;&lt;t1&lt;&lt;&quot; &quot;&lt;&lt;t2&lt;&lt;endl;</span></span><br><span class="line">				ans+=<span class="built_in">min</span>(t1,t2);</span><br><span class="line">				s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">				mp[a[i]]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二分函数lower-bound-upper-bound"><a href="#二分函数lower-bound-upper-bound" class="headerlink" title="二分函数lower_bound upper_bound()"></a>二分函数lower_bound upper_bound()</h2><ol>
<li>在从小到大（单调递增）的数组中：</li>
</ol>
<ul>
<li><p>lower_bound（begin（），end（），num) ：找到第一个大于等于num的数位置指针</p>
</li>
<li><p>upper_bound（begin（），end（），num) ：找到第一个大于num的数位置指针</p>
</li>
</ul>
<ol start="2">
<li>在从大到小（单调递减）的数组中：</li>
</ol>
<ul>
<li>lower_bound（begin（），end（），num，greater&lt;数据类型&gt;（）) ：找到第一个小于等于num的数位置指针</li>
<li>upper_bound（begin（），end（），num，greater&lt;数据类型&gt;（）) ：找到第一个小于num的数位置指针</li>
</ul>
<ol start="3">
<li>重载函数进行自定义比较实现升/降序</li>
</ol>
<ul>
<li><p>lower_bound（begin（），end（），num，cmp) ：找到第一个小于等于num的数位置指针</p>
<ul>
<li><p>自定义函数cmp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">template</span> a,<span class="keyword">template</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    <span class="comment">//实现降序数组，lower_bound()实现寻找第一个小于等于num的位置</span></span><br><span class="line">    <span class="comment">//实现降序数组，upper_bound()实现寻找第一个小于num的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">template</span> a,<span class="keyword">template</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">    <span class="comment">//实现升序数组，lower_bound()实现寻找第一个大于等于num的位置</span></span><br><span class="line">    <span class="comment">//实现升序数组，upper_bound()实现寻找第一个大于num的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="upper-bound-实现vector-lt-gt-容器中每加入一个元素都保证容器中有序"><a href="#upper-bound-实现vector-lt-gt-容器中每加入一个元素都保证容器中有序" class="headerlink" title="upper_bound()实现vector&lt;&gt;容器中每加入一个元素都保证容器中有序"></a>upper_bound()实现vector&lt;&gt;容器中每加入一个元素都保证容器中有序</h2><ul>
<li>显然，set&lt;&gt;容器自然也是能够满足这一要求的，但是set&lt;&gt;却不能快速访问集合中的任一元素，而当vector&lt;&gt;通过upper_bound()便能同时满足上述两个条件，因此这个技巧还是十分有用的。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        v.<span class="built_in">insert</span>(<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x),x);<span class="comment">//二分插入保证单调性</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>) cout&lt;&lt;v[i/<span class="number">2</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;<span class="comment">//在奇数位置输出前i个数的中位数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过两个堆（大顶堆、小顶堆）（优先队列）来保证左右两边分别有序且右边大于左边，</span></span><br><span class="line"><span class="comment">//通过控制在奇数位置保证左边的数目比右边的数目多1，那么左边最大的值即为中位数（大顶堆堆顶 ）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q2;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt; &gt; q1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>()) &#123;q1.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top=q1.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(x&gt;top) q2.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">else</span> q1.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>()!=q2.<span class="built_in">size</span>()+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q1.<span class="built_in">size</span>()&gt;q2.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> tp=q1.<span class="built_in">top</span>();</span><br><span class="line">                    q1.<span class="built_in">pop</span>();</span><br><span class="line">                    q2.<span class="built_in">push</span>(tp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> tp=q2.<span class="built_in">top</span>();</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                    q1.<span class="built_in">push</span>(tp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;q1.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="accumulate累加函数"><a href="#accumulate累加函数" class="headerlink" title="accumulate累加函数"></a>accumulate累加函数</h2><ul>
<li>accumulate带有三个形参：头两个形参指定要累加的元素范围（左闭右开），第三个形参则是累加的初值，第三个参数的类型就是返回值类型（重要）。</li>
<li>同样也可以使用accumulate把string型的vector容器中的元素连接起来：accumulate(v.begin() , v.end() , string(“ “));</li>
</ul>
<h2 id="求前缀和函数partial-sum-begin-end-another-begin"><a href="#求前缀和函数partial-sum-begin-end-another-begin" class="headerlink" title="求前缀和函数partial_sum(begin(),end(),another_begin())"></a>求前缀和函数partial_sum(begin(),end(),another_begin())</h2><ul>
<li>功能：对于前面一个左闭右开的区间求前缀和，注意初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll a[N],pre[N];</span><br><span class="line">pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">partial_sum</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,pre+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="max-element-begin-end"><a href="#max-element-begin-end" class="headerlink" title="max_element(begin(),end())"></a>max_element(begin(),end())</h2><ul>
<li>功能：求一个左闭右开区间中的最大值的下标<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="comment">//求ans[0] - ans[n]中的最大值</span></span><br><span class="line">cout&lt;&lt;*<span class="built_in">max_element</span>(ans,ans+n+<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二分-找前驱（找小于等于x的数中最大的一个）"><a href="#二分-找前驱（找小于等于x的数中最大的一个）" class="headerlink" title="二分-找前驱（找小于等于x的数中最大的一个）"></a>二分-找前驱（找小于等于x的数中最大的一个）</h2><p>通俗的说:找最后一个小于等于x的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">uisng <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">            res=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> high=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">half</span>(x);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[ans]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分-找后继（找大于等于x的数中最小的一个）"><a href="#二分-找后继（找大于等于x的数中最小的一个）" class="headerlink" title="二分-找后继（找大于等于x的数中最小的一个）"></a>二分-找后继（找大于等于x的数中最小的一个）</h2><p>通俗的说:找第一个大于等于x的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">uisng <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">            res=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">half</span>(x);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;a[ans]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串键值对的巧妙利用"><a href="#字符串键值对的巧妙利用" class="headerlink" title="字符串键值对的巧妙利用"></a>字符串键值对的巧妙利用</h2><p>给定n个字符串，若本身字符串为其余某个字符串的子串，则次数加1，求所有字符串的总次数。</p>
<ul>
<li>枚举出所有字符串的子串，用map&lt;string,int&gt;加一进行记录（即map[substring]++），表示该子串代表的字符串可以在该字符串中以子串的形式出现，自然答案加一，但是需要注意的是：枚举的时候一个字符串可能有相同的子串，如aa有子串a、a，枚举到第二个a时不能加1了，因为前面子串a已经出现过了，因此需要用另一个map&lt;string,int&gt;对出现过的字符串进行标记，即如果该子串前面已经出现过了则可以不用处理.</li>
<li>枚举一遍输入的字符串，在map中查询则可以知道它在其他字符串中作为子串出现过多少次，但是需要减1（减去本身），因为该字符串也会在本身的字符串中作为子串出现。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">bool</span>&gt; bmp;<span class="comment">//用string-bool键值对 对出现过的字符串进行标记</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    n=t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        bmp.<span class="built_in">clear</span>();</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len-i+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                string ss=s.<span class="built_in">substr</span>(j,i);</span><br><span class="line">                <span class="keyword">if</span>(bmp[ss]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                bmp[ss]=<span class="number">1</span>;</span><br><span class="line">                mp[ss]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(auto it:mp) cout&lt;&lt;it.first&lt;&lt;&quot; &quot;&lt;&lt;it.second&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=(mp[v[i]]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="c-对pair数据类型进行排序"><a href="#c-对pair数据类型进行排序" class="headerlink" title="c++对pair数据类型进行排序"></a>c++对pair数据类型进行排序</h2><p>利用sort函数也能对pair数组进行排序，若需定义排序规则，只需自定义第三个参数cmp函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i].first&gt;&gt;a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>sum[i][j]表示行数在i以内，列数在j以内的矩形区域的所有的数的和，可以很快计算出某个二维矩形区域中的数的和（i、j尽量从1开始）。</p>
<ul>
<li>例如：当值域为0、1时，求某个二维矩形区域中0或1的个数时不需要O(N^2)遍历，只需要预处理出二维前缀和利用公式即可算出该区域的和，即为1的个数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][j]=sum[i][j<span class="number">-1</span>]+sum[i<span class="number">-1</span>][j]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="AK之神庇佑"><a href="#AK之神庇佑" class="headerlink" title="AK之神庇佑"></a>AK之神庇佑</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//猜猜这是谁？</span></span><br><span class="line">⣿⣿⣿⣿⣿⠟⠋⠄⠄⠄⠄⠄⠄⠄⢁⠈⢻⢿⣿⣿⣿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⠃⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⡀⠭⢿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⡟⠄⢀⣾⣿⣿⣿⣷⣶⣿⣷⣶⣶⡆⠄⠄⠄⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⡇⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠄⠄⢸⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣇⣼⣿⣿⠿⠶⠙⣿⡟⠡⣴⣿⣽⣿⣧⠄⢸⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⣾⣿⣿⣟⣭⣾⣿⣷⣶⣶⣴⣶⣿⣿⢄⣿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⣿⣿⣿⡟⣩⣿⣿⣿⡏⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⣿⣹⡋⠘⠷⣦⣀⣠⡶⠁⠈⠁⠄⣿⣿⣿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⣿⣍⠃⣴⣶⡔⠒⠄⣠⢀⠄⠄⠄⡨⣿⣿⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⣿⣿⣿⣦⡘⠿⣷⣿⠿⠟⠃⠄⠄⣠⡇⠈⠻⣿⣿⣿⣿</span><br><span class="line">⣿⣿⣿⣿⡿⠟⠋⢁⣷⣠⠄⠄⠄⠄⣀⣠⣾⡟⠄⠄⠄⠄⠉⠙⠻</span><br><span class="line">⡿⠟⠋⠁⠄⠄⠄⢸⣿⣿⡯⢓⣴⣾⣿⣿⡟⠄⠄⠄⠄⠄⠄⠄⠄</span><br><span class="line">⠄⠄⠄⠄⠄⠄⠄⣿⡟⣷⠄⠹⣿⣿⣿⡿⠁⠄⠄⠄⠄⠄⠄⠄⠄</span><br><span class="line"></span><br><span class="line"><span class="comment">//            /\       |  /  |**、</span></span><br><span class="line"><span class="comment">//           /  \      | /   |   \</span></span><br><span class="line"><span class="comment">//          /    \     |/    |   /  _____                      ____   |  /</span></span><br><span class="line"><span class="comment">//         /------\    |\    |__/  /     \  \      /\      /  /    \  | /</span></span><br><span class="line"><span class="comment">//        /        \   | \   |    /       \  \    /  \    /  /______\ |/</span></span><br><span class="line"><span class="comment">//       /          \  |  \  |    \       /   \  /    \  /   \        |</span></span><br><span class="line"><span class="comment">//      /            \ |   \ |     \_____/     \/      \/     \_____  |</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┏┓　　 　┏┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃ 　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　━　　 　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　＞　　　＜　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃...　⌒　... 　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┗━┓　　　┏━┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃  　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┗━━━┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　　　　　┣┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　　　　　┏┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　　┃┫┫　┃┫┫</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　　┗┻┛　┗┻┛</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// warm heart, wagging tail,and a smile just for you!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                            _ooOoo_</span></span><br><span class="line"><span class="comment">//                           o8888888o</span></span><br><span class="line"><span class="comment">//                           88&quot; . &quot;88</span></span><br><span class="line"><span class="comment">//                           (| -_- |)</span></span><br><span class="line"><span class="comment">//                           O\  =  /O</span></span><br><span class="line"><span class="comment">//                        ____/`---&#x27;\____</span></span><br><span class="line"><span class="comment">//                      .&#x27;  \|     |//  `.</span></span><br><span class="line"><span class="comment">//                     /  \|||  :  |||//  \</span></span><br><span class="line"><span class="comment">//                    /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">//                    |   | \\  -  /// |   |</span></span><br><span class="line"><span class="comment">//                    | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |</span></span><br><span class="line"><span class="comment">//                    \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">//                  ___`. .&#x27;  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">//               .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.</span></span><br><span class="line"><span class="comment">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">//         ======`-.____`-.___\_____/___.-`____.-&#x27;======</span></span><br><span class="line"><span class="comment">//                            `=---=&#x27;</span></span><br><span class="line"><span class="comment">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机综合</title>
    <url>/2021/10/20/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%BB%BC%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“AC(自动机)的神”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="AC自动机-fail树-树状数组"><a href="#AC自动机-fail树-树状数组" class="headerlink" title="AC自动机+fail树+树状数组"></a>AC自动机+fail树+树状数组</h2><p>题意：给有小写字母构成的大小为3e5的树，有3e5个询问，每个询问给一个限制u和一个字符串t，求树上从根到节点u的路径构成的字符串中t串的出现次数。（询问串的长度总和不超过3e5）</p>
<ul>
<li>思路：将所有查询串全部插入字典树，记录每一个字符串的终止位置即查询编号（即第几个查询，方便输出答案），以及其属于哪一个限制u，该结点在对应限制上的访问次数也就是其出现次数。</li>
<li>若每次暴力暴力对文本串（也就是题中的限制）跑一次AC自动机，那么将是O(N*N)的时间复杂度，因此需要进行进一步优化。</li>
<li>利用字典树的每一个结点与其fail指针反向建立一棵fail树，首先让文本串在字典树上跑一次，每次访问到的结点，那么该结点的访问次数（该结点代表的字符串出现次数加1），那么最终某个结点的访问次数也就是以该结点为根节点的子树上所有结点次数之和。</li>
<li>这样便可以转化为单点修改及区间求和问题，因此用到树状数组的数据结构来进行巧妙的处理，首先通过dfs遍历对fail树每个结点按顺序编号，并数组记录下每个fail树上的结点对应的编号以及以其为根节点的子树中的最大编号（便于对该子树求和），直接上图理解。<br><a href="p1.jpg">p1</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;ask[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N],f[N];<span class="comment">//遇到同时存多个图的情况可以用多张邻接表来处理，不一定用链式前向星</span></span><br><span class="line"><span class="keyword">int</span> node[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N],tree[N],st[N],ed[N],fail[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> tot,dfs_num;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=dfs_num)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x]+=k;</span><br><span class="line">        x+=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=tree[x];</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//对fail树每个结点编一个dfs序，st[u]表示以该结点为跟的子树起始点的编号，ed[u]表示以该节点为跟的子树的最后一个编号（即最大编号）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=++dfs_num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:f[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=dfs_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    state=node[state][s[u]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="built_in">update</span>(st[state],<span class="number">1</span>);<span class="comment">//文本串遍利到该结点，该结点代表的字符串的次数加一，同时也需更新树状数组上的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:ask[u])<span class="comment">//fail树上结点u所代表的字符串出现次数即为该节点以及其子树所有结点出现次数之和</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[it.first]=<span class="built_in">getsum</span>(ed[it.second])-<span class="built_in">getsum</span>(st[it.second]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(it,u,state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(st[state],<span class="number">-1</span>);<span class="comment">//其所有子节点遍历完之后需要进行回溯，那么代表该结点不再被遍历到，该结点代表的字符串的次数减一，同时也需更新树状数组上的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]) node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">        root=node[root][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//字符串插入字典树之后最终到达的结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[u][i]) q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node[u][i]) fail[node[u][i]]=node[fail[u]][i],q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">            <span class="keyword">else</span> node[u][i]=node[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> qes;</span><br><span class="line">    cin&gt;&gt;qes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;str;</span><br><span class="line">        ask[x].<span class="built_in">push_back</span>(&#123;i,<span class="built_in">insert</span>(str)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_fail</span>();<span class="comment">//一定记得加上建立fail指针的过程，忘了太多次了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) f[fail[i]].<span class="built_in">push_back</span>(i);<span class="comment">//对于字典树上每个结点及其fail指针建立fail树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qes;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces</title>
    <url>/2021/11/08/CF/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“Cross Fire!”</font></center>
</blockquote>
<span id="more"></span>
<h1 id="751"><a href="#751" class="headerlink" title="751"></a>751</h1><h2 id="751-B（div1）-BFS"><a href="#751-B（div1）-BFS" class="headerlink" title="751-B（div1）- BFS"></a>751-B（div1）- BFS</h2><p>题意：你是一只青蛙，现在你掉到了一个n米深的井里，当你位于深度为i的位置时，你可以往上跳$[0,a_i]$米中的任意一个整数距离，如果你没有跳出去，那么你需要休息，假设你在深度为j的位置处休息，你就会往下掉$b_j$米，现在请问，最少多少步能跳出去，并且输出跳出去的方案。</p>
<ul>
<li><strong>思路</strong>： 从起始点起跳可以调到的范围为[n-$a_n$，n],而到这一层的跳跃次数均为1，因此可以用BFS的做法一层一层进行遍历，但是到达的每一个点又都会有一个跳跃范围，如果对每一个点都进行一次其下层的遍历，那么时间复杂度是过不去的，因此可以对跳跃过程进行剪枝。</li>
<li><strong>剪枝</strong>：如果本次跳跃的最远距离在上一层或同一层能够跳到的最远距离之内，那么这样一种方案就没必要去讨论了，因此跳跃次数不会有更优，顶多同等最优。因此只需要在每次跳跃之后记录最远能跳到的地点，如果本次跳跃最远跳到的地点没有超过最远点就没有必要进行跳跃了。</li>
<li><strong>细节</strong>：因为对于每次的跳跃范围都是基于跳跃点的，因此BFS队列中记录的是跳跃点的值，而题目要求输出的是下滑的地点而非跳跃点，因此可以记录最优的跳跃点的路径，而每一个跳跃点都有与其对应的下滑点，因此记录跳跃点的时候同时利用映射关系记录其下滑点即可，这样便可输出路径。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N],n;</span><br><span class="line"><span class="keyword">int</span> pre[N],ans[N],path[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> minn=INF;</span><br><span class="line">	<span class="keyword">int</span> tmp,now;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">	<span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(path));</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">	q.<span class="built_in">push</span>(n);</span><br><span class="line">	ans[n]=<span class="number">0</span>;</span><br><span class="line">	path[n]=n;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=t-a[t];i&lt;t;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=minn) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=<span class="number">0</span>) tmp=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> tmp=i,now=i+b[i];</span><br><span class="line">			<span class="keyword">if</span>(ans[now]&gt;ans[t]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans[now]=ans[t]+<span class="number">1</span>;</span><br><span class="line">				pre[now]=t;</span><br><span class="line">				path[now]=tmp;</span><br><span class="line">				q.<span class="built_in">push</span>(now);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		minn=<span class="built_in">min</span>(minn,t-a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans[<span class="number">0</span>]!=INF) <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];	</span><br><span class="line">	<span class="keyword">int</span> top=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">while</span>(pre[x]!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c[++top]=pre[x];</span><br><span class="line">		x=pre[x];</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;pre &quot;&lt;&lt;pre[x]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;top&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=top<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;path[c[i]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="751-div2-C"><a href="#751-div2-C" class="headerlink" title="751-div2-C"></a>751-div2-C</h2><p>题意：给定一个长度为n的数列，从一开始标号，每次可以删除一个a[i] % (i + 1) 不等于0的数，问我们能否删完。</p>
<ul>
<li>思路：对于某个位置为i的数，其可能的位置可以为[1 - i]，前提是其前面的数都有可能被删除，那么判断一个数可不可以被删除也就是看其模[2 - i+1]其中是否存在一个数x能够使得a[i]%x!=0，那么该数也就可以被删除，反之如果不存在x那么该数不会被删除。从正面讨论其能不能被删除不好讨论，因为位置越靠后那么其需要讨论的情形越多，那么可以考虑不能被删除的情形，对于第i个数，如果其不能被删除那么也就是说它能除尽[2 - i+1]中的所有的数。那么也就是说它得是[2  - i + 1 ]中所有数的最小公倍数，这样才能满足除尽的条件，而显然当i=23时，其最小公倍数已然超过了1e^9（数据范围为），那么也就是说对于每一个数只要判断[2 - 23]能否全部整除它也就能知道该数是否能够被删除了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> fin=<span class="number">0</span>;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">			<span class="keyword">if</span>(flag) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=<span class="built_in">min</span>(i+<span class="number">1</span>,<span class="number">23</span>);j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]%j!=<span class="number">0</span>) &#123;fin=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!fin) flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;No\n&quot;</span> ;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="750"><a href="#750" class="headerlink" title="750"></a>750</h1><h2 id="750-div2-A-连续和"><a href="#750-div2-A-连续和" class="headerlink" title="750-div2-A(连续和)"></a>750-div2-A(连续和)</h2><p>题意：给定a个1，b个2，c个3，将其分成两堆，问二堆的差值的绝对值最大为多少？</p>
<ul>
<li>思路：毫无疑问，这些数能够构成的最大的数S为a+2 * b+3 * c，又（a,b,c&gt;=1）,因此可以证明的是这些数能够构成[0 - S]之中的任意一个数，那么也就是说，当S为偶数，那就构造S/2和S/2即可，答案为0；若为奇数，那么构造S/2和S/2+1即可，答案为1。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> a,b,c,t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="keyword">int</span> s=(a+<span class="number">2</span>*b+<span class="number">3</span>*c);</span><br><span class="line">		cout&lt;&lt;(s&amp;<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">		<span class="comment">//--------------------下面是我的分奇偶讨论，这样对比显得我很呆</span></span><br><span class="line">		<span class="comment">// int flag_a=0,flag_b=0,flag_c=0;</span></span><br><span class="line">		<span class="comment">// cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span></span><br><span class="line">		<span class="comment">// if((a&amp;1)==1) flag_a=1;</span></span><br><span class="line">		<span class="comment">// if((b&amp;1)==1) flag_b=1;</span></span><br><span class="line">		<span class="comment">// if((c&amp;1)==1) flag_c=1;</span></span><br><span class="line">		<span class="comment">// if(flag_a&amp;&amp;flag_b&amp;&amp;flag_c)</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// else</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	if(flag_a&amp;&amp;flag_c) cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else if(flag_b&amp;&amp;flag_c) cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else if(flag_a&amp;&amp;flag_b) cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else if(flag_a) cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else if(flag_b) cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else if(flag_c) cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 	else cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="750-div2-E-dp"><a href="#750-div2-E-dp" class="headerlink" title="750-div2-E(dp)"></a>750-div2-E(dp)</h2><p>题意：给定一个数列，求最大的k，使得存在k个首长度为n且长度依次减1但区间总和严格增加的区间。</p>
<ul>
<li>问题转换：给定k之后往后长度递减找区间的话不但k不好确定而且当取完前面的区间后也不好确定后面的长度是否够取到后面剩余的区间，因此可以考虑将数组翻转，然后从前往后找长度每次加1的区间，遍历完整个数列后能最多能推出多少个符合条件（总和依次减少）的区间便是答案k。</li>
<li>状态：dp[i][j]前i个元素中取到j个符合条件的区间且最后一个区间（区间能够取到的最大值）。因为当新加入一个区间时，需要判断该区间是否符合条件时需要知道前面最后一个区间的值是否大于它，那么为了使符合条件的区间最多，那么就势必需要使符合条件的区间能取到的区间和最大化，也就是dp[i][j]取最大值的原因。</li>
<li>转移dp[i][j]=max(dp[i-1][j],sum[i]-sum[i-j])，前者表示不取第i个元素，后者表示取第i个元素，但此处需要判断区间和（sum[i]-sum[i-j]）符合较上个区间和递减的条件，即sum[i]-sum[i-j]&lt;dp[i-j][j-1]。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">ll dp[N][<span class="number">510</span>],a[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//用多少初始化多少，memset严重超时</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">500</span>;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//1个区间的情况无论什么时候都符合，先赋予初值避免与后面的dp[i-1][0]比较</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][<span class="number">1</span>]=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">500</span>&amp;&amp;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">				ll sumn=sum[i]-sum[i-j];</span><br><span class="line">				<span class="keyword">if</span>(sumn&lt;dp[i-j][j<span class="number">-1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i][j]=<span class="built_in">max</span>(dp[i][j],sumn);</span><br><span class="line">					res=<span class="built_in">max</span>(res,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="750-div2-F（dp）"><a href="#750-div2-F（dp）" class="headerlink" title="750-div2-F（dp）"></a>750-div2-F（dp）</h2><p>题意：给定一个序列a(0=&lt; a_i &lt;=500)，求所有严格上升子序列的异或值，并按升序输出。</p>
<ul>
<li>思路：由于序列中的值最大为500，那么异或值的范围也就在0 - 500之间，那么对于当前值来说，它也就只能和之前有过的异或值再次进行异或，且必须满足构成上升子序列，那么可以对所有异或值进行枚举，并记录关键信息，判断能否构成上升子序列。</li>
<li>有了上面的想法，那么就必须记录之前能够成的异或值所对应的上升子序列的最后一个值的最小值，比如：序列8 xor 13 = 3,1 xor 2 = 3,二者同样能够构成异或值3，为了使后续的值和之前的序列构成上升子序列，显然取之前上升序列的较小末尾值比较乐观。</li>
<li>状态：dp[i][j]表示前i个数中能够构造出异或值j的上升子序列的最小末尾值,通过滚动数组可以将dp压缩至以为，因为更新当前的状态后之前的信息以及没有用了。</li>
<li>转移：if(a[i]&gt;dp[j]) dp[j^a[i]]=min(dp[j^a[i]],a[i])<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">   <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">   dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">512</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;dp[j]) dp[a[i]^j]=<span class="built_in">min</span>(a[i],dp[a[i]^j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">512</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]!=INF) ans.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:ans) cout&lt;&lt;it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="EDU-117"><a href="#EDU-117" class="headerlink" title="EDU-117"></a>EDU-117</h1><h2 id="div12-C-二分"><a href="#div12-C-二分" class="headerlink" title="div12-C(二分)"></a>div12-C(二分)</h2>题意：给定一个k，x，共可发送2*k-1次信息，信息量分别为1、2、3、…、k、k-1、k-2、…、1，问在第几次发送的时候发送的信息总量超过了x。</li>
<li>思路：从左至右发送的信息总量呈单调递增的趋势，那么题目便成了问第一个大于等于x的位置。</li>
<li>注意：根据二分的位置mid处于不同的位置，发送的信息总量计算方式也会有所不同。当mid&lt;=k时，总量为(mid+1)* mid/2;当mid&gt;k时，总量res=(k+1)* k/2+(mid-k)*(k-1+k-(mid-k))/2。知道了这一点之后就是很简单的二分过程了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	ll k,x;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">		ll res,ans=<span class="number">2</span>*k<span class="number">-1</span>;</span><br><span class="line">		ll tmp=(k+<span class="number">1</span>)*k/<span class="number">2</span>;</span><br><span class="line">		ll l=<span class="number">1</span>;</span><br><span class="line">		ll r=<span class="number">2</span>*k<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(mid&gt;k)</span><br><span class="line">			&#123;</span><br><span class="line">				ll y=mid-k;</span><br><span class="line">				res=tmp+y*(<span class="number">2</span>*k-y<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				res=mid*(mid+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(res&gt;=x)</span><br><span class="line">			&#123;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">				ans=mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="div-2-D-数学-思维"><a href="#div-2-D-数学-思维" class="headerlink" title="div-2-D(数学+思维)"></a>div-2-D(数学+思维)</h2></li>
<li>题意：给定三个数a、b、x，可以对a、b进行下述操作：将a或b变为|a-b|，问是否可以通过若干次操作使得a或b中出现x。</li>
</ul>
<p>Solution:</p>
<ul>
<li><p>假设我们只对大数a进行操作，那么我们需要保证a&gt;b（通过swap交换）即可。每次可以对a进行减b操作，当a&lt;b时将a、b的值互换保证a&gt;b。</p>
</li>
<li><p>那么会面临三种情况，b&gt;x，那么一步一步将a减b减至刚好大于等于b的过程是没有必要的，我们可以进行一次性减法，总共需要减去b的次数为$cnt=max（1，（a-b）/b）$，如果算出来的次数为0那么也需要对a减去一个b，此时再对（a-cnt*b，b）进行考虑。</p>
</li>
<li><p>a&gt;x&gt;b,那么a此时不能再减至刚好大于等于b了，否则可能错过等于x的过程，那么此时应该减至刚好大于等于x，计算出操作次数$cnt=max（1，（a-x）/b）$,此时再对（a-cnt*b，b）进行考虑。</p>
</li>
<li><p>显然前两种情况可以进行同时考虑，即操作次数$cnt=max（1，（a-max（b，x）/b）$,此时再对（a-cnt*b，b）进行考虑即可。</p>
</li>
<li><p>x&gt;a&gt;b，无解输出NO。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sol</span><span class="params">(ll a,ll b,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==x||b==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((x&gt;a&amp;&amp;x&gt;b)||a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//a=0||b=0时a，b不会再改变了</span></span><br><span class="line">	<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	ll cnt=<span class="built_in">max</span>(<span class="number">1LL</span>,(a-<span class="built_in">max</span>(b,x))/b);<span class="comment">//计算无用的操作次数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sol</span>(a-cnt*b,b,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);	</span><br><span class="line">	ll a,b,t,x;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> res=<span class="built_in">sol</span>(a,b,x);</span><br><span class="line">		<span class="keyword">if</span>(res==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="div2-D-交互-思维"><a href="#div2-D-交互-思维" class="headerlink" title="div2-D(交互+思维)"></a>div2-D(交互+思维)</h2><p>题意：给定1 - n（4=&lt; n &lt;=1e9）的序列，选定三个数i j k使得[i - j-1]和[j - k]区间的数进行翻转（[1,2,3]变为[3,2,1]），现在你可以对任一区间询问逆序对数，问如何询问使得询问次数不超过40次便能求得i j k。</p>
<ul>
<li>思路：第一步求出区间[1 - n]上的逆序数A,其次，不难发现当固定右端点为n后区间[x - n]（1=&lt; x &lt;=n ）上的逆序数非严格单调递减，那么可以通过二分的方式求出逆序数第一个小于等于A的区间左端点i。</li>
<li>通过观察可知,设[i - n]逆序数为A，[i+1 - n]逆序数为B，那么有A-B=j-i，因为对于区间[i+1 - j-1]来说，其相较区间[i - j-1]来说少了元素i的逆序对贡献，由于翻转的关系，其可以与[i+1,j-1]上的元素构成逆序对，那么后者区间减少的逆序对数为j-(i+1)+1=j-i，A与B可以通过询问求得，而前面已经求出i，那么通过等式A-B=j-i可解得j。</li>
<li>同理：设[j - n]逆序数为C，[j+1 - n]逆序数为D,那么有C-D=k-j，亦可通过询问得知C、D，因此可求得k。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">unordered_map&lt;ll,unordered_map&lt;ll,ll&gt; &gt; mp;<span class="comment">//实现二元组对一元组 mp[a][b]=c;</span></span><br><span class="line"><span class="function">ll <span class="title">cmb</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half</span><span class="params">(ll x,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r=n;</span><br><span class="line">	ll tmp;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;mid&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">			res=mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n,i,j,k;</span><br><span class="line">	ll A,B,C,D,E;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="comment">//首先询问[1 , n]区间</span></span><br><span class="line">		cin&gt;&gt;A;</span><br><span class="line">		i=<span class="built_in">half</span>(A,n);<span class="comment">//二分查找i</span></span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;i:  &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="comment">//询问[i+1 , n]区间</span></span><br><span class="line">		cin&gt;&gt;B;</span><br><span class="line">		j=A-B+i+<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;j: &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">		D=A-<span class="built_in">cmb</span>(j-i);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="comment">//询问[j+1 , n]区间</span></span><br><span class="line">		cin&gt;&gt;E;</span><br><span class="line">		k=D-E+j;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="EDU-116"><a href="#EDU-116" class="headerlink" title="EDU-116"></a>EDU-116</h1><h2 id="EDU-116-div2-E-dp-思维"><a href="#EDU-116-div2-E-dp-思维" class="headerlink" title="EDU-116-div2-E(dp+思维)"></a>EDU-116-div2-E(dp+思维)</h2>题意：有 n 个人，他们要进行下面的进程：每轮设存活 i 个人，那么每个人会减少 i−1 的血量，血量小于等于零就会被淘汰，现在需要你给他们每个人设置一个在 [1,x] 之间的初始血量，使得某轮游戏结束后，无人生还，求这样的方案数。</li>
<li>在这个题目中，初始状态就是n个具有初始血量的人，而我们需要得到的是最终场上没人的状态，那么可以考虑是否可以通过状态转移来得到最终状态的方案数。</li>
<li>状态：dp[i][j]定义为现在存活i个人并且受到伤害j（因为人数是和伤害挂钩的，i个人在某一回合会对其余某个人造成i-1点伤害，但是不能这一轮过后的存活人数，故可以对存活人数进行枚举，也就是状态转移，而存活人数为0的状态就是我们想要的状态）。</li>
<li>转移：dp[k][j+i-1]=(dp[k][j+i-1]+(dp[i][j] * cmb(i,i-k)%mod) * qsm(（j+i-1）-j,i-k)%mod)%mod，该状态由dp[i][j]进行状态转移，cmb(i , i-k)表示组合数从i个人中选（i-k）个人死亡，$qsm(（j+i-1）-j,i-k)即((j+i-1)-j)^{i-k}$表示这i-k个人血量的方案数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">ll C[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">ll p[<span class="number">510</span>];</span><br><span class="line">ll dp[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="function">ll <span class="title">qsm</span><span class="params">(ll a,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">    a=a*a%mod;</span><br><span class="line">    k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cmb</span><span class="params">(ll n,ll k)</span><span class="comment">//组合数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=((p[n]*<span class="built_in">qsm</span>(p[k],mod<span class="number">-2</span>)%mod)*<span class="built_in">qsm</span>(p[n-k],mod<span class="number">-2</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//杨辉三角求组合数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,x;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      p[i]=p[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    dp[n][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> dam=<span class="built_in">min</span>(x,(ll)j+i<span class="number">-1</span>);<span class="comment">//i个人造成伤害i-1，累计伤害为j+i-1,而造成的伤害最多只有最大值x，限制上界方便统计结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;=<span class="number">0</span>;k--)<span class="comment">//i个人中剩余k个人，从i个人中选i-k个人死亡，且这i-k的血量只能在(j,dam]之间，否则就不会死，故血量的方案为(dam-j)^(i-k)</span></span><br><span class="line">            &#123;</span><br><span class="line">              dp[k][dam]=(dp[k][dam]+(dp[i][j]*<span class="built_in">cmb</span>(i,i-k)%mod)*<span class="built_in">qsm</span>(dam-j,i-k)%mod)%mod;<span class="comment">//状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;i++)<span class="comment">//统计最终结果</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans=(ans+dp[<span class="number">0</span>][i])%mod;</span><br><span class="line">      <span class="comment">//cout&lt;&lt;dp[0][i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="EDU-111-div2-C"><a href="#EDU-111-div2-C" class="headerlink" title="EDU-111-div2-C"></a>EDU-111-div2-C</h2><p>题意:给定一个数组，如果一个子区间数组能找出一个三元组p($a_i$,i)、q($a_j$,j)、r($a_k$,k)（i,j,k为数组元素下标），满足d ( p , r ) = d ( p , q ) + d ( q , r )（d为曼哈顿距离），那么这个就是坏数组，求是好数组的子区间数组个数。</p>
<ul>
<li>思路：容易想到如果一个区间中有三个元素的值构成非严格单调递减或者非严格单调递增，那么该子区间数组为坏数组。</li>
<li>结论：对于长度超过4的子区间数组，一定存在三个元素构成非严格单调递减或者非严格单调递增序列，因此长度超过5的子区间数组都是坏数组，不需要考虑，因此只需要枚举长度为3、4的子区间数组进行判断即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">2</span>) &#123;cout&lt;&lt;<span class="number">3</span>&lt;&lt;endl;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(r&lt;=n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x=a[l];</span><br><span class="line">			<span class="keyword">int</span> y=a[l+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> z=a[l+<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">if</span>((x&lt;=y&amp;&amp;y&lt;=z)||(x&gt;=y&amp;&amp;y&gt;=z)) cnt1++;</span><br><span class="line">			l++;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=(n<span class="number">-2</span>-cnt1);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l=<span class="number">1</span>;</span><br><span class="line">			r=<span class="number">4</span>;</span><br><span class="line">			<span class="keyword">while</span>(r&lt;=n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> x=a[l];</span><br><span class="line">				<span class="keyword">int</span> y=a[l+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">int</span> z=a[l+<span class="number">2</span>];</span><br><span class="line">				<span class="keyword">int</span> k=a[l+<span class="number">3</span>];</span><br><span class="line">				<span class="comment">//cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; </span></span><br><span class="line">				<span class="keyword">if</span>((x&lt;=y&amp;&amp;y&lt;=z)||(x&gt;=y&amp;&amp;y&gt;=z)||(x&lt;=z&amp;&amp;z&lt;=k)||(x&gt;=z&amp;&amp;z&gt;=k)||(y&lt;=z&amp;&amp;z&lt;=k)||(y&gt;=z&amp;&amp;z&gt;=k)||(x&lt;=y&amp;&amp;y&lt;=k)||(x&gt;=y&amp;&amp;y&gt;=k)) cnt2++;</span><br><span class="line">				l++;</span><br><span class="line">				r++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;&quot;cnt2&quot;&lt;&lt;&quot; &quot;&lt;&lt;cnt2&lt;&lt;endl;</span></span><br><span class="line">			ans+=(n<span class="number">-3</span>-cnt2);</span><br><span class="line">			cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CF-1598-D-思维"><a href="#CF-1598-D-思维" class="headerlink" title="CF-1598-D(思维)"></a>CF-1598-D(思维)</h2><p>题意：现在有n个物品，每个物品有两个值$a_i$、$b_i$，现在问从n个物品中选3个物品，要保证这三个物品的$a_i$值个不相同或$b_i$值各不相同，问方案数共有多少种？</p>
<p>Solution</p>
<ul>
<li>直接从正面考虑符合条件的方案数那么需要考虑的情况很多，那么可以考虑从总方案数中减去不符合情况的便是符合条件的。</li>
<li>总方案数：C(n,3)，不符合条件的就是选出的三个数中a值同时有两个相同，b值有两个相同。那么只需要对于每个物体根据a值选出一个相同的物品，根据b值选一个相同的物品，由于题目保证了不会有相同的物品（即a、b值相同），那么一定能够选出3种物品，而且不会重复。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">ll a[MAXN],b[MAXN];</span><br><span class="line">unordered_map&lt;ll,ll&gt; cnta,cntb;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	ll t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnta.<span class="built_in">clear</span>();</span><br><span class="line">		cntb.<span class="built_in">clear</span>();</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">	 		cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">			cnta[a[i]]++;</span><br><span class="line">			cntb[b[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=(n)*(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">6</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans-=((cnta[a[i]]<span class="number">-1</span>)*(cntb[b[i]]<span class="number">-1</span>));<span class="comment">//减去不符合条件的方案数，不会重复</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Edu-123-div2"><a href="#Edu-123-div2" class="headerlink" title="Edu-123(div2)"></a>Edu-123(div2)</h2><h3 id="C-Increase-Subarray-Sums"><a href="#C-Increase-Subarray-Sums" class="headerlink" title="C. Increase Subarray Sums"></a>C. Increase Subarray Sums</h3><ul>
<li>题目来源：<a href="https://codeforces.com/contest/1644/problem/C">EDU - 123</a></li>
<li>题意：给定一个长度为n的整数数组a和一个数x，求当在数组a上加上k（k: 0 - n）个数时最长字段和.</li>
<li>思路；首先考虑一般做法：求出所有n ^ 2个字段和，在这n ^ 2个字符和上进行对应的加k个数的操作然后取最大值。仔细观察便会发现对于一个长度为l的区间，当k&lt;=l时，其区间和会增加k * x，当k&gt;l时其区间和会增加l * x;那么也就是说对于相同长度的字段区间，对于同一个k其能增加的值是一样的，因此我们只需要考虑相同长度子段中的最大子段，用ans[i]表示长度为i时的最大子段和。接下来只需要枚举k从0 - n然后对于不同长度的区间加上对应的值然后取最大值输出即可.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll pre[N],a[N],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	ll t,x,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		<span class="built_in">partial_sum</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,pre+<span class="number">1</span>);</span><br><span class="line">		ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans[i]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans[j-i+<span class="number">1</span>]=<span class="built_in">max</span>(ans[j-i+<span class="number">1</span>],pre[j]-pre[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;*<span class="built_in">max_element</span>(ans,ans+n+<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=i) ans[j]+=x;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==n) cout&lt;&lt;*<span class="built_in">max_element</span>(ans,ans+n+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span> cout&lt;&lt;*<span class="built_in">max_element</span>(ans,ans+n+<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="772-div2"><a href="#772-div2" class="headerlink" title="772-div2"></a>772-div2</h2><h3 id="D-Infinite-Set"><a href="#D-Infinite-Set" class="headerlink" title="D. Infinite Set"></a>D. Infinite Set</h3><ul>
<li>题意：给定一个有n正整数的集合，你可以对集合中的任一元素进行吐下操作：<br>y = x<em>2 +1<br>y = x</em>4<br>并且将y加入集合中，问其中会有多少个数小于2^p( 1≤ n,p ≤2e5) </li>
<li>思路：由于p的范围很大，不能用一般的类型来存储2^p，于是可以想到用二进制来表示，而且其中对x的操作其实也就是二进制移位操作（左移移位加1 或左移两位），考虑划定的范围需要小于2^p（也就是最小的P+1位二进制数），那么只要集合中的位数小于等于p那么也就是符合条件的，对位数进行分析的话，那么上述的操作无非就是让x的位数 加1 或 加2。</li>
<li>于是可以想到用dp[i]表示位数为i的数的个数，状态转移方程为：<pre><code>  if(i-1&gt;=0) dp[i]=(dp[i]+dp[i-1])%mod;
  if(i-2&gt;=0) dp[i]=(dp[i-2]+dp[i])%mod;
</code></pre>
</li>
<li>注意：需要对初始状态集中的元素进行去重，否则部分结果会重复计算，比如：集合为{2,5}，5可以由2转变而来，集合中会出现2个5，他们能够产生的新的元素是一样的，因此会导致重复计算；那么只需要将集合中的元素从小到大排序后暴力往下搜索看已经去重的集合中是否出现（比如：2往下搜索发现2不会重复，5往下搜索2是否出现），将不会重复出现的数放入去重的集合。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll dp[N];</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line">unordered_map&lt;ll,<span class="keyword">bool</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unique</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(__lg(a[i])+<span class="number">1</span>&gt;p) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		ll x=a[i];</span><br><span class="line">		<span class="keyword">while</span>(x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v.<span class="built_in">find</span>(x)!=v.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(x&amp;<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">else</span> x&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) &#123;v[a[i]]=<span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int n,p;</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Unique</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;it:  &quot;&lt;&lt;it&lt;&lt;&quot;  &quot; &lt;&lt;&quot;num:  &quot;&lt;&lt;__lg(it)+1&lt;&lt;endl;</span></span><br><span class="line">		dp[__lg(it.first)+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=p;i++) cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) dp[i]=(dp[i]+dp[i<span class="number">-1</span>])%mod;</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>) dp[i]=(dp[i<span class="number">-2</span>]+dp[i])%mod;</span><br><span class="line">		ans=(ans+dp[i])%mod;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/2021/08/16/LRU/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“LRU，你真是一个LRU!”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="LRU的简单实现"><a href="#LRU的简单实现" class="headerlink" title="LRU的简单实现"></a>LRU的简单实现</h2><p>题意：给出n个作业，问至少要多少块物理存储空间（cache），才能使得执行该n个作业时有k次能在cache中访问某个作业而不用发生中断</p>
<ul>
<li>cache块越大越有可能使某个作业能在cache中被访问到，容易想到答案是单调的，因此二分cache块的大小。</li>
<li>本来以为是个傻逼题，想着用链表和数组去模拟，主要是被上次那道题的思路带偏了，若该作业已经存在与cache中的情况非要想着找到它并且删除它，之后再在对手插入一个当前时间的该作业，但是不要求指明某个作业在内存块中的具体位置时只需标记该作业在内存块中并且记录下该作业的最近访问时间即可，脑子确实是没有转开。</li>
<li>由于知道替换时是替换最久未访问的也就是时间最小的，那么应该想到用优先队列来维护一下即可，每次弹出一个最小时间（即最久未访问的）的作业。但是当一个作业来到时该作业在内存中存在时需要更新该作业的时间（进入cache的时间），有了上面的思路后容易知道，改变之后该作业总是在cache中的，所以不需要进行遍历优先队列将该作业弹出更新时间后再压入，那么就只要用mp记录更新该作业的时间即可，如果某次替换操作弹出了该作业但是发现其时间已经被更新了那么就将该就作业弹出更新时间后再压入优先队列中，此时再弹出一个时间最小的进行替换直到弹出作业的时间与记录的该作业的时间一致时说明该作业的访问时间没有被更新，那么就替换掉该作业。<br><a href="https://codeforces.com/gym/103366/problem/J">LRU</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> ne[N],val[N],a[N],n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t;	</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">Node</span> (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">		t=a;</span><br><span class="line">		w=b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(Node a,Node b)</span><span class="comment">//同运算符&#x27;&lt;&#x27;</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.t&gt;b.t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pq.<span class="built_in">size</span>()) pq.<span class="built_in">pop</span>();</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		time++;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">			mp[a[i]]=time;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mp[a[i]])<span class="comment">//作业不在cache中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pq.<span class="built_in">size</span>()&lt;mid)<span class="comment">//cache空间还有剩余直接压入</span></span><br><span class="line">				&#123;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">					mp[a[i]]=time;<span class="comment">//记录时间</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Node x=pq.<span class="built_in">top</span>();</span><br><span class="line">					<span class="keyword">while</span>(x.t!=mp[x.w])<span class="comment">//弹出作业的时间与记录的时间不符，说明后续被重新访问过</span></span><br><span class="line">					&#123;</span><br><span class="line">						pq.<span class="built_in">pop</span>();</span><br><span class="line">						pq.<span class="built_in">push</span>(&#123;mp[x.w],x.w&#125;);<span class="comment">//弹出旧的作业及其时间，压入作业及其新的时间</span></span><br><span class="line">						x=pq.<span class="built_in">top</span>();</span><br><span class="line">					&#125;	</span><br><span class="line">					mp[x.w]=<span class="number">0</span>;</span><br><span class="line">					pq.<span class="built_in">pop</span>();</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">					mp[a[i]]=time;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				res++;</span><br><span class="line">				mp[a[i]]=time;<span class="comment">//更改该作业的被访问时间</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;=k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> high=n;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;check(3)&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(high+low)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;</span><br><span class="line">			ans=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;cbddl&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure</title>
    <url>/2021/09/07/Data-Structure/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“老子混常胜山的，你小子哪座山头的？”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><blockquote>
<center>以我目前的理解对树状数组的知识进行记录描述</center>
</blockquote>
<h3 id="单点修改，区间查询"><a href="#单点修改，区间查询" class="headerlink" title="单点修改，区间查询"></a>单点修改，区间查询</h3><p>在某些区间求和的问题上，容易想到用前缀和的知识处理可以快速查询任意区间的和，但是若是遇到对某点的值进行更新的情况，那么用前缀和的方法进行更新sum[]数组的值时间复杂度会变为O（N），这样的处理方法太慢了，由此可以引入树状数组这一数据结构进行优化。空口无凭，老表，上图。<br><img src="/images/loading.png" data-original="/2021/09/07/Data-Structure/1.bmp" alt="树状数组"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>],c[<span class="number">1005</span>]; <span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//从低位到高位第一位为1的位置的值，如6（110），lowbit（6）=2（10）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span><span class="comment">//在i位置加上k</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//求A[1 - i]的和</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对差分数组建立树状数组（区间修改，单点查询）"><a href="#对差分数组建立树状数组（区间修改，单点查询）" class="headerlink" title="对差分数组建立树状数组（区间修改，单点查询）"></a>对差分数组建立树状数组（区间修改，单点查询）</h3><p><a href="https://www.luogu.com.cn/problem/P3368">LG - P3368</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		c[x]+=k;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=c[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,x,m,y,z,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">update</span>(i,a[i]-a[i<span class="number">-1</span>]);<span class="comment">//对差分数组建立树状数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;z;</span><br><span class="line">    	<span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;<span class="comment">//对区间[x,y]的数加k，即是对c[x]+k,c[y+1]-k,c为差分数组</span></span><br><span class="line">    		<span class="built_in">update</span>(x,k);</span><br><span class="line">    		<span class="built_in">update</span>(y+<span class="number">1</span>,-k);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		cin&gt;&gt;x;<span class="comment">//求第x个数，即是差分数组的前x项和</span></span><br><span class="line">    		cout&lt;&lt;<span class="built_in">sum</span>(x)&lt;&lt;endl;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用差分数组实现区间查询（区间修改区间查询）"><a href="#利用差分数组实现区间查询（区间修改区间查询）" class="headerlink" title="利用差分数组实现区间查询（区间修改区间查询）"></a>利用差分数组实现区间查询（区间修改区间查询）</h3><p>上面我们说的差值建树状数组，得到的是某个点的值，那如果我既要区间更新，又要区间查询怎么办。这里我们还是利用差分，由上面可知(D为差分数组)</p>
<p>$\sum^n_{i = 1}A[i] = ∑^n_{i = 1} ∑^i_{j = 1}D[j];$</p>
<p>则A[1]+A[2]+…+A[n]</p>
<p>= (D[1]) + (D[1]+D[2]) + … + (D[1]+D[2]+…+D[n]) </p>
<p>= n*D[1] + (n-1)*D[2] +… +D[n]</p>
<p>= n * (D[1]+D[2]+…+D[n]) - (0 * D[1]+1 * D[2]+…+(n-1) * D[n])</p>
<p>所以上式可以变为$∑^n_{i = 1}A[i] = n<em>∑^n_{i = 1}D[i] -  ∑^n_{i = 1}( D[i]</em>(i-1) );$</p>
<p>理解了树状数组的作用后那么可以维护两个数状数组便能能够实现区间查询了，令D1[i] = D[i]，D2[i] = D[i]*(i-1)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">int</span> D1[<span class="number">50005</span>];    <span class="comment">//(D[1] + D[2] + ... + D[n])</span></span><br><span class="line"><span class="keyword">int</span> D2[<span class="number">50005</span>];    <span class="comment">//(0*D[1] + 1*D[2] + ... + (n-1)*D[n])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = i;    <span class="comment">//因为x不变，所以得先保存i值</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">        D1[i] += k;</span><br><span class="line">        D2[i] += (x<span class="number">-1</span>) * k;</span><br><span class="line">        i += i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;        <span class="comment">//求前缀和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, x = i;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += x * D1[i] - D2[i];</span><br><span class="line">        i -= i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">update</span>(i,a[i] - a[i<span class="number">-1</span>]);   <span class="comment">//输入初值的时候，也相当于更新了值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[x,y]区间内加上k</span></span><br><span class="line">    <span class="built_in">update</span>(x,k);    </span><br><span class="line">    <span class="built_in">updatae</span>(y+<span class="number">1</span>,-k);        </span><br><span class="line"></span><br><span class="line">    <span class="comment">//求[x,y]区间和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">getsum</span>(y) - <span class="built_in">getsum</span>(x<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组维护前n个值的最大-小值"><a href="#树状数组维护前n个值的最大-小值" class="headerlink" title="树状数组维护前n个值的最大/小值"></a>树状数组维护前n个值的最大/小值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;N)</span><br><span class="line">	&#123;</span><br><span class="line">		c[x]=<span class="built_in">max</span>(c[x],k);</span><br><span class="line">		x+=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		res=<span class="built_in">max</span>(res,c[x]);</span><br><span class="line">		x-=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="离散化-树状数组"><a href="#离散化-树状数组" class="headerlink" title="离散化+树状数组"></a>离散化+树状数组</h2><p>给定n（$1=&lt; n &lt;=1e^{5}$）个坐标，每个坐标都有一个价值。问你从(0,0)走到(1e9,1e9)能获得的最大价值之和（你可以向右,向上，向右上走。只有从左下向右上走到该坐标点才能才能获得该价值）。</p>
<ul>
<li>本题能够想到的最直接的方法是进行二维dp，但是时间复杂度太高接受不了，因为每一维都上升到了$1e^9$的维度，果断放弃。然后发现虽然范围是$1e^9$，但是给出的数据最多只有$1e^5$，因此可以想到离散化，对输入的纵坐标y离散化，用unordered_map对输入的纵坐标y从小到大分别从1开始映射至n，也就是离散化。<ul>
<li>后续使用dp求解，考虑状态方程：d[y]表示到达坐标y时能够获得的最大价值，因为只有从斜下角进入才能获得价值，那么状态转移方程可以表示$d[y]=max_{i=1}^{y-1}d[i]+val$,val为该点的价值。</li>
</ul>
</li>
<li>状态转移之前需要对所有的进行排序，横坐标x小的在前，横坐标相纵坐标大的优先，因为当横坐标相同时需要先更新y值大的d[y],因为他需要用到的$max_{i=1}^{y-1}d[i]$应该是前一轮的值，若是向更新y值小的点，那么更新大的y值点是用到本轮即横坐标相同的$max_{i=1}^{y-1}d[i]$，而同一横坐标的点不满足从斜左下方进入，不能用前面的转移方程。</li>
<li>值得一提的是：本题的最大值的维护需要用到树状数组来进行维护，但是用树状数组只能求得前n个数即区间[1 - n]（n为任意数）的最大值，而不能求得任意区间的最大值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> b[N],c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.x==b.x) <span class="keyword">return</span> a.y&gt;b.y;<span class="comment">//同横坐标，纵坐标大的在前先更新</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.x&lt;b.x;<span class="comment">//横坐标小的在前更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;N)</span><br><span class="line">	&#123;</span><br><span class="line">		c[x]=<span class="built_in">max</span>(c[x],k);</span><br><span class="line">		x+=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		res=<span class="built_in">max</span>(res,c[x]);</span><br><span class="line">		x-=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;node[i].x&gt;&gt;node[i].y&gt;&gt;node[i].w;</span><br><span class="line">			b[i]=node[i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mp[b[i]]) mp[b[i]]=++cnt;<span class="comment">//对纵坐标y的值从0开始映射</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmp);<span class="comment">//对所有的点进行排序</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> pos=mp[node[i].y];<span class="comment">//pos为该纵坐标y的映射</span></span><br><span class="line">			<span class="keyword">int</span> val=<span class="built_in">getmax</span>(pos<span class="number">-1</span>)+node[i].w;<span class="comment">//getmax(pos-1)为区间[1 - pos-1]的最大值</span></span><br><span class="line">			<span class="built_in">update</span>(pos,val);<span class="comment">//更新d[pos]处(本代码中当val&lt;d[pos]时是不能更新的，但因为树状数组维护的是最大值，因此直接这样写没有关系)的值并利用树状数组维护最大值</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">getmax</span>(N<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="树状数组-二分-数学"><a href="#树状数组-二分-数学" class="headerlink" title="树状数组+二分+数学"></a>树状数组+二分+数学</h2>题意：给两个长度为n的序列(a1,a2……,an)、(b1,b2……bn)和m个询问以及一个整数k，找出满足k &lt;= S(t) = $\sum_1^n((t-b_i) / a_i)$（/为向下取整）的最小t（ 1 ≤ $a_i$ ≤ 1000, 1 ≤ bi , k ≤ 1e9）。</li>
<li>首先，由于t的表达式具有有单调性，因此可以想到二分寻找答案。</li>
<li>上述公式可以化简为S(t) = $\sum_1^n((t/a_i-b_i/a_i+(t%a_i-b_i%a_i)&lt;0?-1:0))$</li>
<li>由于$a_i$的数据范围很小，因此可以对a进行归纳，统计出1-1000内$a_i$的出现个数并用数组num记录，$\sum_1^n(t/a_i) =\sum_{i=1}^{1000} t/i * num[i]$。</li>
<li>对于一个数$a_i$,用对应每个$a_i$的树状数组存储$b_i%a_i$的值的个数，因为我们可以利用树状数组求和求出小于等于$t%a_i$的$b_i%a_i$值的个数tot,用num[a[i]]-tot即为$b_i%a_i$大于$t%a_i$的个数，也就是公式后部需要减去-1的数目，需要用到树状数组是因为后续可能会面临单点修改操作，修改之后继续求和若不用树状数组维护暴力求和时间复杂度会很高。</li>
<li>需要注意的是树状数组存储的是每个a_i对应的$b_i$%$a_i$的个数分布，如$b_i$=3,a_i=2$,那么$a_i$=2对应的树状数组就要将c[$b_i$%$a_i$]即c[3%2=1]++,又因为模上a_i之后结果可能为0，但是树状数组的下标只能从1开始，因此对每次计算的结果加1处理作为需更新的树状数组的下标位置。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(x&lt;N)</span><br><span class="line">		&#123;</span><br><span class="line">			c[x]+=d;</span><br><span class="line">			x+=x&amp;-x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(x)</span><br><span class="line">		&#123;</span><br><span class="line">			res+=c[x];</span><br><span class="line">			x-=x&amp;-x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],num[N];</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp+=((ll)(t/i)*num[i]-(num[i]-tree[i].<span class="built_in">getsum</span>(t%i+<span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	tmp-=sum;</span><br><span class="line">	<span class="keyword">if</span>(tmp&gt;=k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n,m;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">		<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">			num[a[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;b[i];</span><br><span class="line">			sum+=(b[i]/a[i]);</span><br><span class="line">			tree[a[i]].<span class="built_in">update</span>(b[i]%a[i]+<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> op,x,y;</span><br><span class="line">			cin&gt;&gt;op;</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">				sum=sum-b[x]/a[x]+b[x]/y;</span><br><span class="line">				num[a[x]]--;</span><br><span class="line">				num[y]++;</span><br><span class="line">				tree[a[x]].<span class="built_in">update</span>((b[x]%a[x])+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">				tree[y].<span class="built_in">update</span>((b[x]%y)+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">				a[x]=y;</span><br><span class="line">				<span class="comment">//cout&lt;&lt;&quot;sum: &quot;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">				sum=sum-b[x]/a[x]+y/a[x];</span><br><span class="line">				tree[a[x]].<span class="built_in">update</span>((b[x]%a[x])+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">				tree[a[x]].<span class="built_in">update</span>((y%a[x])+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">				b[x]=y;</span><br><span class="line">				<span class="comment">//cout&lt;&lt;&quot;sum: &quot;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cin&gt;&gt;k;</span><br><span class="line">				ll ans=<span class="number">0</span>;</span><br><span class="line">				ll low=<span class="number">1</span>,high=<span class="number">1e12</span>;</span><br><span class="line">				<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">				&#123;</span><br><span class="line">					ll mid=(low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">					&#123;</span><br><span class="line">						high=mid<span class="number">-1</span>;</span><br><span class="line">						ans=mid;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						low=mid+<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LRU的简单实现（优先队列）"><a href="#LRU的简单实现（优先队列）" class="headerlink" title="LRU的简单实现（优先队列）"></a>LRU的简单实现（优先队列）</h2><p>题意：给出n个作业，问至少要多少块物理存储空间（cache），才能使得执行该n个作业时有k次能在cache中访问某个作业而不用发生中断</p>
<ul>
<li>cache块越大越有可能使某个作业能在cache中被访问到，容易想到答案是单调的，因此二分cache块的大小。</li>
<li>本来以为是个傻逼题，想着用链表和数组去模拟，主要是被上次那道题的思路带偏了，若该作业已经存在与cache中的情况非要想着找到它并且删除它，之后再在对手插入一个当前时间的该作业，但是不要求指明某个作业在内存块中的具体位置时只需标记该作业在内存块中并且记录下该作业的最近访问时间即可，脑子确实是没有转开。</li>
<li>由于知道替换时是替换最久未访问的也就是时间最小的，那么应该想到用优先队列来维护一下即可，每次弹出一个最小时间（即最久未访问的）的作业。但是当一个作业来到时该作业在内存中存在时需要更新该作业的时间（进入cache的时间），有了上面的思路后容易知道，改变之后该作业总是在cache中的，所以不需要进行遍历优先队列将该作业弹出更新时间后再压入，那么就只要用mp记录更新该作业的时间即可，如果某次替换操作弹出了该作业但是发现其时间已经被更新了那么就将该就作业弹出更新时间后再压入优先队列中，此时再弹出一个时间最小的进行替换直到弹出作业的时间与记录的该作业的时间一致时说明该作业的访问时间没有被更新，那么就替换掉该作业。<br><a href="https://codeforces.com/gym/103366/problem/J">LRU</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> ne[N],val[N],a[N],n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t;	</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">Node</span> (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">		t=a;</span><br><span class="line">		w=b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(Node a,Node b)</span><span class="comment">//同运算符&#x27;&lt;&#x27;</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.t&gt;b.t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pq.<span class="built_in">size</span>()) pq.<span class="built_in">pop</span>();</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		time++;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">			mp[a[i]]=time;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mp[a[i]])<span class="comment">//作业不在cache中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pq.<span class="built_in">size</span>()&lt;mid)<span class="comment">//cache空间还有剩余直接压入</span></span><br><span class="line">				&#123;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">					mp[a[i]]=time;<span class="comment">//记录时间</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Node x=pq.<span class="built_in">top</span>();</span><br><span class="line">					<span class="keyword">while</span>(x.t!=mp[x.w])<span class="comment">//弹出作业的时间与记录的时间不符，说明后续被重新访问过</span></span><br><span class="line">					&#123;</span><br><span class="line">						pq.<span class="built_in">pop</span>();</span><br><span class="line">						pq.<span class="built_in">push</span>(&#123;mp[x.w],x.w&#125;);<span class="comment">//弹出旧的作业及其时间，压入作业及其新的时间</span></span><br><span class="line">						x=pq.<span class="built_in">top</span>();</span><br><span class="line">					&#125;	</span><br><span class="line">					mp[x.w]=<span class="number">0</span>;</span><br><span class="line">					pq.<span class="built_in">pop</span>();</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;time,a[i]&#125;);</span><br><span class="line">					mp[a[i]]=time;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				res++;</span><br><span class="line">				mp[a[i]]=time;<span class="comment">//更改该作业的被访问时间</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;=k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> high=n;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;check(3)&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(high+low)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;</span><br><span class="line">			ans=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;cbddl&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="线段树单点修改"><a href="#线段树单点修改" class="headerlink" title="线段树单点修改"></a>线段树单点修改</h3><ul>
<li><p>线段树中的每个节点都代表一个区间（可以理解为线段），每个节点维护的是父亲的区间二等分后的其中一个子区间</p>
</li>
<li><p>线段树具有唯一的根节点，根节点维护的是整个区间，代表的区间是整个统计范围，比如有序列a[1]~a[N]，那么根节点所代表的区间就是[1,N]。</p>
</li>
<li><p>线段树的每个叶子节点都代表一个长度为1的元区间[x,x]</p>
</li>
<li><p>对于 每个内部节点[l,r]，它的左子节点是[l,mid]，右子节点是[mid+1,r]，其中mid=(l+r)/2向下取整</p>
</li>
<li><p>当有n个元素时，对区间的操作可以在O(logn)的时间内完成，空间复杂度为O(n)。</p>
</li>
<li><p>用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。</p>
<pre><code>  符合区间加法的例子：
  最大值： 总最大值=max(左区间最大值，右区间最大值)
  数字之和：总数字之和 = 左区间数字之和 + 右区间数字之和
  最大公因数(GCD)： 总GCD = gcd( 左区间GCD , 右区间GCD )
</code></pre>
</li>
</ul>
<p><strong>区间最大值：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson p*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson p*2+1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">int</span> maxn;</span><br><span class="line">&#125;tr[<span class="number">4</span>*MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[u].maxn=<span class="built_in">max</span>(tr[u*<span class="number">2</span>].maxn,tr[u*<span class="number">2</span>+<span class="number">1</span>].maxn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[p].l=l,tr[p].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].maxn=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//一定return，否则死循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(lson,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].l==tr[p].r)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].maxn=v;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(tr[p].l+tr[p].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">update</span>(rson,x,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">update</span>(lson,x,v);</span><br><span class="line">	tr[p].maxn=<span class="built_in">max</span>(tr[lson].maxn,tr[rson].maxn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  res=-INF;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r) <span class="keyword">return</span> tr[p].maxn;</span><br><span class="line">	<span class="keyword">int</span> mid=((tr[p].l+tr[p].r)/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(lson,l,r));</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(rson,l,r));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,k,x,y;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>区间最大连续子段和</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson p*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson p*2+1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">int</span> maxn;<span class="comment">//整个区间最大连续字段和</span></span><br><span class="line">	<span class="keyword">int</span> sum;<span class="comment">//区间和</span></span><br><span class="line">	<span class="keyword">int</span> lmax;<span class="comment">//区间靠左连续和最大值</span></span><br><span class="line">	<span class="keyword">int</span> rmax;<span class="comment">//区间靠右连续和最大值</span></span><br><span class="line">&#125;tr[<span class="number">4</span>*MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node l, Node r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.maxn = <span class="built_in">max</span>(<span class="built_in">max</span>(l.maxn, r.maxn), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[p].l=l,tr[p].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) </span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].maxn=a[l];</span><br><span class="line">		tr[p].sum=a[l];</span><br><span class="line">		tr[p].lmax=a[l];</span><br><span class="line">		tr[p].rmax=a[l];</span><br><span class="line">		<span class="comment">//按顺序一次性赋值，tr[p]=&#123;a[l],a[l],a[l],a[l]&#125;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(tr[p],tr[lson],tr[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].l==tr[p].r)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].maxn=v;</span><br><span class="line">		tr[p].sum=v;</span><br><span class="line">		tr[p].lmax=v;</span><br><span class="line">		tr[p].rmax=v;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(tr[p].l+tr[p].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">update</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">update</span>(p*<span class="number">2</span>,x,v);</span><br><span class="line">	<span class="built_in">pushup</span>(tr[p],tr[lson],tr[rson]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].r&lt;=r&amp;&amp;tr[p].l&gt;=l) <span class="keyword">return</span> tr[p];</span><br><span class="line">	<span class="keyword">int</span> mid=((tr[p].l+tr[p].r)/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid&amp;&amp;r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">auto</span> left=<span class="built_in">query</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">		<span class="keyword">auto</span> right=<span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">		Node res;</span><br><span class="line">		<span class="built_in">pushup</span>(res,left,right);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,k,x,y;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y).maxn&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>,x,y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段树区间修改"><a href="#线段树区间修改" class="headerlink" title="线段树区间修改"></a>线段树区间修改</h2><h3 id="区间和模板"><a href="#区间和模板" class="headerlink" title="区间和模板"></a>区间和模板</h3><p>在“区间查询”指令中，每当遇到被询问区间[l,r]完全覆盖的节点时，可以立即把该节点上存储的信息作为候选答案返回。已经有大佬证明，被询问区间[l,r]在线段树上会被分成O(logN)个小区间(节点)从而在O(logN)的时间内求出答案。</p>
<p>我们在执行修改指令时，同样可以在 l&lt;= P.l &lt;= P.r &lt;= r 的情况下立即返回，只不过在回溯之前向节点P增加一个标记，标识“该节点曾经被修改过，但其子节点尚未被更新”。为什么不立即向下遍历该区间的子区间然后对它们进行修改呢？那是因为如立即对其下所有区间进行修改，首先时间复杂度是o（n（其所有子区间））的，并且有可能查询区间和时根本不需要查询其子区间的值，那么这样会浪费大量的时间，因此可以对该区间节点打上延迟标记，待到查询时需要用到其子节点的信息时再进行更新。</p>
<p>如果在后续的指令中，需要从节点P向下递归，我们再检查P是否具有标记。若有标记，就根据标记信息更新P的两个子节点，同时为P的两个子节点增加标记，然后清除P的标记。</p>
<p>也就是说，除了在修改指令中直接划分成的O(logN)个节点之外，对任意给点的修改都延迟到“在后续操作中递归进入他的父亲节点时”再执行。这样一来，每条查询或修改指令的时间复杂度都降低到了O(logN)。这些标记被称为“延迟标记”。延迟标记提供了线段树中从上往下传递信息的方式。这种“延迟”也是设计算法与解决问题的一个重要思路。</p>
<p>区间修改大致分为两步：</p>
<ol>
<li>找到区间中全部都是要修改的点的<strong>线段树中的区间</strong></li>
<li>修改这一段区间的所有点</li>
</ol>
<p>比如总区间是 [1,10] 现在要让区间[2,8]的值都加上5</p>
<p>将总区间分割[1,5] [6,10] 再分割 [1,3] [4,5] [6,8] [9,10] 我们的目的是让分割的区间满足真包含于要修改的区间</p>
<p>然后直接修改这一分割区间的sum值，然后用lazy标记，然后再进入spread函数更新该点子树的sum值</p>
<p>如更新[2,8] 则其实是更新了区间 [2,2] [3,3] [4,5] [6,8] 每找到一个这样的真包含区间就加上lazy标记</p>
<p>懒惰标记<br>标记的含义：本区间已经被更新过了，但是子区间却没有被更新过。</p>
<p>核心就是：我们可以直接修改一个大区间的值，并不需要修改他的子节点，等我们需要单独提出该子节点信息的时候再下传这个懒标记并修改这个子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson p*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson p*2+1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	ll sum;<span class="comment">//区间和</span></span><br><span class="line">	ll alt;<span class="comment">//该区间的延迟标记</span></span><br><span class="line">&#125;tr[<span class="number">4</span>*MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//向上更新信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[p].sum=tr[lson].sum+tr[rson].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//延迟标记向下传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].alt)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[lson].sum+=tr[p].alt*(tr[lson].r-tr[lson].l+<span class="number">1</span>);</span><br><span class="line">		tr[rson].sum+=tr[p].alt*(tr[rson].r-tr[rson].l+<span class="number">1</span>);</span><br><span class="line">		tr[lson].alt+=tr[p].alt;</span><br><span class="line">		tr[rson].alt+=tr[p].alt;</span><br><span class="line">		tr[p].alt=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[p].l=l,tr[p].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//一定return，否则死循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(lson,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tr[p].l&amp;&amp;r&gt;=tr[p].r)<span class="comment">//找到能够完全被更新区间（l，r）覆盖的区间，更新其值但不再往下传递，打上标记即可</span></span><br><span class="line">	&#123;</span><br><span class="line">		tr[p].sum+=(ll)d*(tr[p].r-tr[p].l+<span class="number">1</span>);</span><br><span class="line">		tr[p].alt+=d;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spread</span>(p);<span class="comment">//更新两个子区间的值，并将标记向下传递（因为标记过的区间其值已经被修改过了，所以直接向下修改即可）</span></span><br><span class="line">	<span class="keyword">int</span> mid=(tr[p].l+tr[p].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//左右两个区间都要判断，有交集就递归</span></span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rson,l,r,d);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(lson,l,r,d);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r) <span class="keyword">return</span> tr[p].sum;</span><br><span class="line">	<span class="built_in">spread</span>(p);<span class="comment">//更新两个子区间的值，并将标记向下传递</span></span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=((tr[p].l+tr[p].r)/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) res=+<span class="built_in">query</span>(lson,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rson,l,r);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,k,x,y,d;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;c&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;d;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>,x,y,d);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="区间有关问题"><a href="#区间有关问题" class="headerlink" title="区间有关问题"></a>区间有关问题</h2><p>将第一个节点作为根节点，从第一个位置开始向后遍历，其位置及其能到达的最远位置构成一个区间，将此区间进行合并，若最终所有区间能够覆盖该数组表示范围，则表示终点可达，也就是说最终能够合并成一个完整区间，那么重点的父节点fa[n-1]即为0（起始结点）。</p>
<p><a href="https://leetcode-cn.com/problems/jump-game/">力扣 - 55</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">30010</span>];</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">find</span>(i);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n&amp;&amp;j&lt;=i+nums[i];j++) fa[j]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa[n<span class="number">-1</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">canJump</span>(v)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph Theory</title>
    <url>/2024/06/27/Graph%20Theory/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“万象神宫?!!!”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="求有向图中的字典序最小的最长路径"><a href="#求有向图中的字典序最小的最长路径" class="headerlink" title="求有向图中的字典序最小的最长路径"></a>求有向图中的字典序最小的最长路径</h2><ul>
<li>题意：给定一个有向图，求经过根节点的字典序最小的最长路径</li>
<li>题目来源：<a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361">天梯训练</a></li>
<li>思路：确定入度为0的点即为根节点，那么便通过DFS遍历出所有的最长路径，通过比较找出字典序最小的最长路径即可。</li>
<li>本体难度不高，但是确实提醒了我修改DFS的写法而活的更高的准确率或者说节省更多的空间</li>
<li>记录路径时不再需要每次传入一个vector<int>，只需要开一个全局数组以及记录栈顶的指针tp，通过更改栈顶位置便能够实现在dfs中的前进以及回退从而达到记录所有可能路径的结果。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; adj[N];</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"><span class="keyword">int</span> tp;</span><br><span class="line"><span class="keyword">int</span> deg[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stk[tp++]=root;</span><br><span class="line">	<span class="keyword">if</span>(adj[root].<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tp&gt;(<span class="keyword">int</span>)ans.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;&quot;&gt;&gt;&gt;  :&quot;&lt;&lt;root&lt;&lt;endl;</span></span><br><span class="line">			ans.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp;i++) ans.<span class="built_in">push_back</span>(stk[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tp==(<span class="keyword">int</span>)ans.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(stk[i]&gt;ans[i]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(stk[i]==ans[i]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!flag)</span><br><span class="line">			&#123;</span><br><span class="line">				ans.<span class="built_in">clear</span>();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tp;i++) ans.<span class="built_in">push_back</span>(stk[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:adj[root])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	tp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n,k,x,root;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			deg[x]++;</span><br><span class="line">			<span class="built_in">add</span>(i,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deg[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			root=i;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">back</span>();</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议的写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; adj[N];</span><br><span class="line"><span class="keyword">int</span> deg[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a,vector&lt;<span class="keyword">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,vector&lt;<span class="keyword">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v.<span class="built_in">push_back</span>(root);</span><br><span class="line">	<span class="keyword">if</span>(adj[root].<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.<span class="built_in">size</span>()&gt;ans.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			ans=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(v.<span class="built_in">size</span>()==ans.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">cmp</span>(v,ans))</span><br><span class="line">			&#123;</span><br><span class="line">				ans=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// v.resize(0);</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:adj[root])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(it,v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k,x,root;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			deg[x]++;</span><br><span class="line">			<span class="built_in">add</span>(i,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(deg[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			root=i;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="built_in">dfs</span>(root,v);</span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">back</span>();</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h2 id="求树上直径"><a href="#求树上直径" class="headerlink" title="求树上直径"></a>求树上直径</h2></int></li>
</ul>
<ol>
<li>树形dp求直径，代码简洁好写，但记录路径较复杂，但可以求带负权的树的直径<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> ne[<span class="number">2</span>*N],head[N],to[<span class="number">2</span>*N],edge[<span class="number">2</span>*N],d[N],tot,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ne[++tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	to[tot]=v;</span><br><span class="line">	edge[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diameter</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//dp求答案，因此不能在里面定义ans，只能定义全局变量求出直径ans</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">diameter</span>(v,u);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,d[u]+d[v]+edge[i]);</span><br><span class="line">		d[u]=<span class="built_in">max</span>(d[u],d[v]+edge[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,u,v,w;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)<span class="comment">//点的序号为1 - n</span></span><br><span class="line">	&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		ans=-INF;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="comment">//n-1条边</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			<span class="built_in">add</span>(u,v,w);</span><br><span class="line">			<span class="built_in">add</span>(v,u,w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">diameter</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>两次DFS(/BFS)求直径，代码较树形dp复杂，但是能够很好的记录路径，但不可以求带负权的树的直径<br><a href="1.jpg">求直径误区</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> ne[<span class="number">2</span>*N],head[N],to[<span class="number">2</span>*N],edge[<span class="number">2</span>*N],d[N],pre[N],tot,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ne[++tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	to[tot]=v;</span><br><span class="line">	edge[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = ne[i]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        pre[v]=u;<span class="comment">//前驱结点</span></span><br><span class="line">        d[v] = d[u] + edge[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameter</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> far,root,ans;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(d[i]&gt;ans) </span><br><span class="line">        &#123;</span><br><span class="line">            far=i;</span><br><span class="line">            ans=d[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    ans=-INF;</span><br><span class="line">    root=far;</span><br><span class="line">    <span class="built_in">dfs</span>(far,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(d[i]&gt;ans)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ans=d[i];</span><br><span class="line">    		far=i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//路径输出</span></span><br><span class="line">    <span class="comment">// while(pre[far])</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;far&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// 	far=pre[far];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;root&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,w;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            <span class="built_in">add</span>(u,v,w);</span><br><span class="line">            <span class="built_in">add</span>(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">diameter</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tarjan求强连通分量"><a href="#tarjan求强连通分量" class="headerlink" title="tarjan求强连通分量"></a>tarjan求强连通分量</h2></li>
</ol>
<ul>
<li><p>求强连通分量数目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> head[N],to[N],ne[N],vis[N],dfn[N],low[N],cnt,ans,tot,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ne[++tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//此代码仅供参考</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    low[u]=dfn[u]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>)  <span class="built_in">Tarjan</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">1</span>)  low[u]=<span class="built_in">min</span>(low[u],low[v]);<span class="comment">//某个点再次遍历到，说明已经成环了，回溯更新low值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])<span class="comment">//dfs序和low值相等时说明存在一个强连通分量</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> m,u,v;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<span class="comment">//n个点，m条边，点的编号从1 - n</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			<span class="built_in">add</span>(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对强连通分量缩点染色</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="dijkstra（二维数组实现）"><a href="#dijkstra（二维数组实现）" class="headerlink" title="dijkstra（二维数组实现）"></a>dijkstra（二维数组实现）</h2><p>用于求单源最短路，用二维数组存储各边的值，空间复杂度为O（n^2）,数据量超过1e5便不再适用，但是更新dis[n]的值方便</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> di;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        i=a;</span><br><span class="line">        di=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.di&gt;b.di;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="keyword">int</span> val[N][N];</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;N;i++) dis[i]=INF;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,dis[1]); </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            val[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,i,a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;,dis[1],dis[2]);  </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            val[a][b]=c;</span><br><span class="line">            val[b][a]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node <span class="title">root</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            node v=q.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d\n&quot;,v.i,v.di);</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(vis[v.i]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v.i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i]&amp;&amp;dis[i]&gt;dis[v.i]+val[v.i][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d %d\n&quot;,i,v.i,dis[v.i],val[v.i][i]);</span></span><br><span class="line">                    dis[i]=dis[v.i]+val[v.i][i];</span><br><span class="line">                    <span class="function">node <span class="title">tmp</span><span class="params">(i,dis[i])</span></span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(tmp);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="dijkstra（链式前向星实现）"><a href="#dijkstra（链式前向星实现）" class="headerlink" title="dijkstra（链式前向星实现）"></a>dijkstra（链式前向星实现）</h2><p>用链式前向星存储各点的邻接边，适用于数据量较大的情况，但是实现以及理解起来不太方便，也用于更新dis[n]的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> di;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        i=a;</span><br><span class="line">        di=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,v,next;</span><br><span class="line">&#125;e[<span class="number">2</span>*N];;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.di&gt;b.di;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s,tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">        head[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    e[tot].val=c;</span><br><span class="line">    e[tot].v=b;</span><br><span class="line">    e[tot].next=head[a];</span><br><span class="line">    head[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node <span class="title">root</span><span class="params">(s,dis[s])</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">//for(int i=head[t];i!=-1;i=e[i].next) printf(&quot;%d &quot;,i);</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[tmp.i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[tmp.i]=<span class="number">1</span>;</span><br><span class="line">        t=tmp.i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[t];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[i].v;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d %d %d %d\n&quot;,t,y,dis[t],dis[y],e[i].val);</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[y]&amp;&amp;dis[t]+e[i].val&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[t]+e[i].val;</span><br><span class="line">                <span class="function">node <span class="title">x</span><span class="params">(y,dis[y])</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,dis[i],i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><p>求任意两点间的最短路径,主要在于数据的预处理，后续跟上三个for循环就行，<del>没什么好说得</del>,确实逮说两句。借助中间点来更新的那一层for循环得放在最外层，顺序不能调换，即k-i-j，用一层循环k按次序不断更新dis[i][j]的值，最终更新后的值即为任意两点最短距离。</p>
<ul>
<li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1869">HDU - 1869</a></li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,k,finish,x,y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;   </span><br><span class="line">        finish=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) dis[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dis[i][j]=INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            dis[x][y]=<span class="number">1</span>;</span><br><span class="line">            dis[y][x]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]&gt;<span class="number">7</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    finish=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(finish!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(finish!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><p>求n个点的最小生成树，依次取权值最小的边，且该边的两个端点不在一个集合中（用并查集来处理判断），最后取到n-1条边即为最小生成树。</p>
<ul>
<li><a href="https://vjudge.net/problem/POJ-1258">POJ_1258</a></li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        v1=a;</span><br><span class="line">        v2=b;</span><br><span class="line">        e=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载优先队列的比较符(值较小的在队首)</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.e&gt;b.e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优先队列默认值较大的优先级高（在队首），这里重载过后值小的在队首</span></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="comment">//并查集找集合公共祖先，</span></span><br><span class="line"><span class="comment">//用于判断集合相交及集合的合并</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);<span class="comment">//不能加else</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v,a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;<span class="comment">//初始化每个点为一个单独集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%n==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                x=i/n;</span><br><span class="line">                y=n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x=i/n+<span class="number">1</span>;</span><br><span class="line">                y=i%n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            <span class="comment">//printf(&quot;i:%d %d %d %d\n&quot;,i,x,y,v);</span></span><br><span class="line">            <span class="keyword">if</span>(y&lt;=x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="function">node <span class="title">tmp</span><span class="params">(x,y,v)</span></span>;</span><br><span class="line">            q.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            node x=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            a=<span class="built_in">find</span>(x.v1);</span><br><span class="line">            b=<span class="built_in">find</span>(x.v2);</span><br><span class="line">            <span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum+=x.e;</span><br><span class="line">            <span class="comment">//printf(&quot;e:%d\n&quot;,x.e);</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//此时n-1条边的树即为最小生成树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连通图构造"><a href="#连通图构造" class="headerlink" title="连通图构造"></a>连通图构造</h2><p>题意：（这里只提题目中比较难理解的部分）给定n个点，每个点均连接d条边（保证n&gt;=d+1），问如何构造出合理的图。</p>
<ul>
<li>该图形的度为n<em>d，由于n</em>d/2为边数，故n*d只能为偶数，否则不能构造。</li>
<li>当d为奇数时，每个点分别向左向右连接（d-1）/2条边，再与其对面的点相连，总共d条边，此图形满足条件。</li>
<li>当d为奇数时，每个点分别向左向右连接d/2条边，总共d条边，此图形满足条件。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; adj[N];<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n,c,d;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	adj[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADD_EDGE</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed,<span class="keyword">int</span> odd,<span class="keyword">int</span> rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt,pos;</span><br><span class="line">	<span class="keyword">if</span>(odd==<span class="number">1</span>) cnt=(d<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> cnt=d/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=st;i&lt;=ed;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pos=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)<span class="comment">//向右连边</span></span><br><span class="line">		&#123;</span><br><span class="line">			pos+=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(pos&gt;ed) pos=st;</span><br><span class="line">			<span class="built_in">add</span>(i,pos);</span><br><span class="line">		&#125;</span><br><span class="line">		pos=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)<span class="comment">//向右连边</span></span><br><span class="line">		&#123;</span><br><span class="line">			pos-=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(pos&lt;st) pos=ed;</span><br><span class="line">			<span class="built_in">add</span>(i,pos);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(odd==<span class="number">1</span>) <span class="built_in">add</span>(i,(i+rest/<span class="number">2</span>)&gt;ed?(i-rest/<span class="number">2</span>):(i+rest/<span class="number">2</span>));<span class="comment">//连对面的边</span></span><br><span class="line">		<span class="built_in">sort</span>(adj[i].<span class="built_in">begin</span>(),adj[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">int</span> vlen=adj[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vlen;j++) </span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;adj[i][j];</span><br><span class="line">			<span class="keyword">if</span>(j==vlen<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;d&gt;&gt;c;</span><br><span class="line">	<span class="keyword">if</span>(d==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==n) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(n/<span class="number">2</span>==c) </span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>) cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">					<span class="keyword">else</span> cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len=d+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> num=n/len;</span><br><span class="line">		<span class="keyword">int</span> rest=n-(c<span class="number">-1</span>)*len;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;=c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((rest&amp;<span class="number">1</span>)==<span class="number">1</span>&amp;&amp;(d&amp;<span class="number">1</span>)==<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> st,ed;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;c;k++)<span class="comment">//前c-1个连通块的构造（d+1个点，每个点连d条边，即完全图）</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(k==<span class="number">1</span>) &#123;st=<span class="number">1</span>;ed=len;&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						st+=len;</span><br><span class="line">						ed+=len;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//cout&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;st&lt;&lt;&quot; &quot;&lt;&lt;ed&lt;&lt;endl;</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> i=st;i&lt;=ed;i++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(i==st)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+d;j++)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span>(j==i+d) cout&lt;&lt;j;</span><br><span class="line">								<span class="keyword">else</span> cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							cout&lt;&lt;endl;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">for</span>(<span class="keyword">int</span> j=st;j&lt;i;j++)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span>(i==ed&amp;&amp;j==i<span class="number">-1</span>) cout&lt;&lt;j;</span><br><span class="line">								<span class="keyword">else</span> cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=ed;j++)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span>(j==ed) cout&lt;&lt;j;</span><br><span class="line">								<span class="keyword">else</span> cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							cout&lt;&lt;endl;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(c==<span class="number">1</span>)&#123;st=<span class="number">1</span>;ed=n;&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;st+=len;ed=n;&#125;</span><br><span class="line">				<span class="comment">//--------------------</span></span><br><span class="line">                <span class="comment">//st为起始点，ed为终止点</span></span><br><span class="line">				<span class="keyword">if</span>(d%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//d为奇数构图</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">ADD_EDGE</span>(st,ed,<span class="number">1</span>,rest);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//d为偶数构图</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">ADD_EDGE</span>(st,ed,<span class="number">0</span>,rest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>End</strong></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>kruskal</tag>
        <tag>floyed</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>Math</title>
    <url>/2021/11/24/Math/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p>整除分块是用于快速处理形似 $\sum _{i=1}^{n}⌊k/i⌋$的式子。</p>
<p>o(n)的方法显然大家都会，但是当数据量较大时就有点乏力了，因此需要优化。<br>令n=5，sum=5+2+1+1+1，可以发现，对于单一的$⌊k/i⌋$，某些地方的值是相同的，并且呈块状分布。</p>
<p>而对于一个块，假设它的起始位置的下标为l，那么该块的结束位置的下标为$⌊k⌊k/l⌋⌋$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= n; l++) </span><br><span class="line">&#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>例题：<a href="https://vjudge.net/problem/%E9%BB%91%E6%9A%97%E7%88%86%E7%82%B8-1257">余数之和</a></li>
</ul>
<p>求$$∑_{i=1}^nk%i$$</p>
<p>看似和上面提到的整除分块没有关系，但实际上上述的式子可以转化为$∑_{i=1}^nk-⌊k/i ⌋<em>i$，进一步转化为$n</em>k-∑_{i=1}^n⌊k/i ⌋*i$，但是后面式子不是单纯的整除分块，还需要进一步转化。</p>
<p>对于一个分块来说，设其块内的值为T，那么有$∑_{i=l}^rT<em>i$，即$T</em>∑_{i=l}^ri$,后面的部分实际上就是一个等差数列，那么也就可以进行分块计算了，时间复杂度o（$\sqrt{n}$）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="comment">//数论分块入门</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	ll n,k;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	ll l,r;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;k) &#123;ans+=(n-k)*k;n=k;&#125;</span><br><span class="line">	<span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=<span class="built_in">min</span>(k/(k/l),n);</span><br><span class="line">		ans+=(r-l+<span class="number">1</span>)*k-(k/l)*(r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;l:&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整除分块与积性函数"><a href="#整除分块与积性函数" class="headerlink" title="整除分块与积性函数"></a>整除分块与积性函数</h2><p>说到积性函数，就不得不讲到两个广为人知的函数ϕ,μ，这是我们最熟悉的积性函数（其实我也只知道这两个）</p>
<p>积性函数有一个很好用的性质（设f(i)为一个积性函数）：</p>
<p>$$f(i∗j)=f(i)∗f(j)$$</p>
<p>这里的f(i)其实是一个完全积性函数（ϕ就不是一个完全积性函数：$ϕ(i∗j)=ϕ(i)∗ϕ(j)$当且仅当i，j互质才成立）。好了，讲完积性函数的这个性质后我们步入正题，整除分块与积性函数的联系<br>很多时候，我们推出来整除分块的式子不是很裸的，常与其他函数结合（通常是积性函数，通常为μ或ϕ）这个时候如何统计答案呢？<br>比如：</p>
<p>$$\sum_{i=1}^{n}μ(i)∗⌊n/i⌋$$</p>
<p>积性函数的性质！<br>因为积性函数这个很好用的性质，所以我们可以直接对前半段的莫比乌斯函数维护一个前缀和，再利用整除分块处理式子的后半段，处理答案的时候，把两段相乘即可。</p>
<h2 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h2><ul>
<li>经过nlogn的预处理之后，可以O(1)的算出某个区间的最大最小值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们设二维数组dp[i][j]表示从第i位开始连续$2^j$</span></span><br><span class="line"><span class="comment">//个数中的最小值。例如dp[2][1]就表示从第二位数开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），dp[i][0]就表示第i个数字本身。</span></span><br><span class="line"><span class="comment">//循环循序别写错，区间dp要么起始点从后往前推，要么区间长度从小往大推。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq_init</span><span class="params">()</span> <span class="comment">//RMQ初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;=n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]); <span class="comment">//i + (1 &lt;&lt; (j - 1))</span></span><br><span class="line">    <span class="comment">//左移操作符的优先级小于加号的优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.lanqiao.cn/problems/1375/learning/">m计划</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">500010</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> k=(<span class="keyword">int</span>)<span class="built_in">log2</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        dp[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">min</span>(dp[i][k],dp[i+m<span class="number">-1</span>-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));<span class="comment">//当区间长度不是2的k次方时进行区间拆分,m-（1&lt;&lt;k）为剩下的未覆盖到的区间</span></span><br><span class="line">                                                             <span class="comment">//k为log2（区间长度）向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2021/08/16/String/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“听君一席话，如听一席话”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="手写hash-map"><a href="#手写hash-map" class="headerlink" title="手写hash_map"></a>手写hash_map</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsz=<span class="number">4e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="comment">//素数表:1e7+19,2e7+3,3e7+23</span></span><br><span class="line"><span class="comment">//1e6+3,2e6+3,3e6+7,4e6+9,1e5+3,2e5+3,3e5+7,4e5+9</span></span><br><span class="line"><span class="comment">//要保证取值的操作次数小于maxsz,maxsz最好为素数</span></span><br><span class="line"><span class="comment">//count操作不增加新节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ull u;<span class="keyword">int</span> v,next;&#125;e[maxsz&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[maxsz],nume,numk,id[maxsz];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(ull u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hs=u%maxsz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[hs];i;i=e[i].next)</span><br><span class="line">        <span class="keyword">if</span>(e[i].u==u) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](ull u)&#123;</span><br><span class="line">    <span class="keyword">int</span> hs=u%maxsz;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[hs];i;i=e[i].next)</span><br><span class="line">      <span class="keyword">if</span>(e[i].u==u) <span class="keyword">return</span> e[i].v;</span><br><span class="line">    <span class="keyword">if</span>(!head[hs])id[++numk]=hs;</span><br><span class="line">    <span class="keyword">return</span> e[++nume]=(node)&#123;u,<span class="number">0</span>,head[hs]&#125;,head[hs]=nume,e[nume].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=numk;i++) head[id[i]]=<span class="number">0</span>;</span><br><span class="line">    numk=nume=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h2><ul>
<li>利用两组进制值与模值同一字符串进行hash操作得到两个hash值，用pair&lt;ull,ull&gt;表示一个字符串的hash值，只有这两个值同时相等才能说明该字符串为同一字符串，这样能很大程度避免冲突的发生。</li>
<li>十分惨痛的教训！！！！</li>
<li>特别注意：所有hash值的存储最好不要用unsigned long long 来存储，因为对于某个字串其hash值的计算过程为：hash = (hs[r]-hs[l-1]*pec[r-l+1]%mod+mod)%mod;那么hs[r]-hs[l-1]…的过程可能产生负数，而变量属于无符号正数，那么便会转为正数，导致与原来的计算结果不符，造成出错。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const ull base=2333333;</span></span><br><span class="line"><span class="comment">// const ull mod=999999998;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ull base=13331;</span></span><br><span class="line"><span class="comment">// const ull mod=91815541;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ull,ull&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ull hs1[N],hs2[N],peac1[N],peac2[N],pec=<span class="number">131</span>;</span><br><span class="line">ull mod1=<span class="number">1e9</span>+<span class="number">7</span>,mod2=<span class="number">1e9</span>+<span class="number">11</span>;</span><br><span class="line">map&lt;PII,ull&gt; mp;  </span><br><span class="line">PII v[N];</span><br><span class="line"><span class="function">ull <span class="title">get1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (hs1[r]-hs1[l<span class="number">-1</span>]*peac1[r-l+<span class="number">1</span>]%mod1+mod1)%mod1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">get2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (hs2[r]-hs2[l<span class="number">-1</span>]*peac2[r-l+<span class="number">1</span>]%mod2+mod2)%mod2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="built_in">get1</span>(l,r),<span class="built_in">get2</span>(l,r)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,n,tot=<span class="number">0</span>;</span><br><span class="line">	peac1[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	peac2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++) peac1[i]=peac1[i<span class="number">-1</span>]*pec%mod1;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++) peac2[i]=peac2[i<span class="number">-1</span>]*pec%mod2;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> cs=<span class="number">1</span>;cs&lt;=n;cs++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			hs1[i]=(hs1[i<span class="number">-1</span>]*pec%mod1+s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>)%mod1;</span><br><span class="line">			hs2[i]=(hs2[i<span class="number">-1</span>]*pec%mod2+s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>)%mod2;</span><br><span class="line">		&#125;</span><br><span class="line">		mp[&#123;hs1[len],hs2[len]&#125;]++;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i+i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">get</span>(<span class="number">1</span>,i)==<span class="built_in">get</span>(len-i+<span class="number">1</span>,len))</span><br><span class="line">			&#123;</span><br><span class="line">				v[++tot]=<span class="built_in">get</span>(i+<span class="number">1</span>,len-i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ull ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=tot;i++) ans+=mp[v[i]];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> t:mp) ans+=(t.second*(t.second<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串快速匹配-kmp"><a href="#字符串快速匹配-kmp" class="headerlink" title="字符串快速匹配(kmp)"></a>字符串快速匹配(kmp)</h2><p>通过建立一个失配数组next[n]用于存储匹配串中每一个位置失配后的位置用于快速定位而避免重复检查，从而大大提高匹配效率。</p>
<ul>
<li><a href="https://vjudge.net/problem/HDU-2087">HDU-2087</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2000</span>],str1[<span class="number">2000</span>],str2[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">int</span> ne[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt,j,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1+<span class="number">1</span>)&amp;&amp;str1[<span class="number">1</span>]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2+<span class="number">1</span>);</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(str1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len2=<span class="built_in">strlen</span>(str2+<span class="number">1</span>);</span><br><span class="line">        ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;str2[i]!=str2[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">            <span class="keyword">if</span>(str2[i]==str2[j+<span class="number">1</span>]) j++;</span><br><span class="line">            ne[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;str1[i]!=str2[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">            <span class="keyword">if</span>(str1[i]==str2[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==len2) </span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j=<span class="number">0</span>;    <span class="comment">//字符串不重复匹配</span></span><br><span class="line">                <span class="comment">//j=ne[j];字符串可重复匹配</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="kmp求字符串最小循环节"><a href="#kmp求字符串最小循环节" class="headerlink" title="kmp求字符串最小循环节"></a>kmp求字符串最小循环节</h2><ul>
<li>结论：长度为n的字符串的最小循环节长度表示为：xlen=n-next[n]。举一个一般的例子帮助自己理解，设str=”abababab”,由m(4)个最小的完整循环节构成，即n=xlen*(m),则next[n]=6，即m-1(3)个最小循环节，所以next[n]=(m-1)*xlen,则 n - next[n] 等于一个最小循环节的长度xlen，因此n-next[n]即为长度为n的字符串的最小循环节长度。若字符串由不完整的循环节构成，此时n-next[n]不再表示最小循环节长度，他撒谎也不是，举个🌰：设str=”abcab”,此时n=5、next[5]=2,n-next[n]=3,由n%（n-next[n])!=0,故n-next[n]不可能成为最小循环节。</li>
<li>总结：若要求最小循环节，首先求出n-next[n],若n-next[n]能整除总长度n，则n-next[n]即为最小循环节长度，反之则不是（其本身为其循环节）。<blockquote>
<p>“文字是苍白无力滴。”</p>
</blockquote>
</li>
<li><a href="https://vjudge.net/problem/HDU-3746">HDU - 3746</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i]) j=ne[j];</span><br><span class="line">            <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i]) j++;</span><br><span class="line">            ne[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> xlen=len-ne[len];</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,xlen);</span></span><br><span class="line">        <span class="keyword">if</span>(xlen==len) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len%xlen==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,xlen-(len%xlen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="kmp求所有相同的前缀、后缀字符串"><a href="#kmp求所有相同的前缀、后缀字符串" class="headerlink" title="kmp求所有相同的前缀、后缀字符串"></a>kmp求所有相同的前缀、后缀字符串</h2><p>假设有长度为n的字符串，首先求出next数组，next[n]表示该字符串中最长的相同前缀后缀字符串的长度，故可以在从长为next[n]的字符串中继续寻找相同的前缀后缀字符串，其结果也为原始字符串(长度为n的字符串)的相同前缀后缀字符串，以此类推，直到结果为0，即没有的相同前缀后缀字符串了。举个🌰：abcdab abcdab，此处next[12]=6,next[6]=2,next[2]=0,故长为2、6的前缀字符串”ab”、”abcdab”亦为后缀字符串,且系该字符串所有的相同前缀后缀字符串。</p>
<ul>
<li>题目来源：codeforces 126 B<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; ss;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp=len;</span><br><span class="line">    ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125; </span><br><span class="line">    len=ne[len];</span><br><span class="line">    <span class="keyword">while</span>(len)</span><br><span class="line">    &#123;   </span><br><span class="line">        ss.<span class="built_in">insert</span>(len);<span class="comment">//将相同前缀后缀字符串的长度插入集合ss</span></span><br><span class="line">        len=ne[len];<span class="comment">//回溯查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ss.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Just a legend\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=tmp<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ss.<span class="built_in">count</span>(ne[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,ne[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Just a legend\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="kmp求最长后缀回文字符串"><a href="#kmp求最长后缀回文字符串" class="headerlink" title="kmp求最长后缀回文字符串"></a>kmp求最长后缀回文字符串</h2><p>给定字符串s，若求最长后缀回文字符串,先将s倒转为rev，将s作为模板串、rev作为匹配串,用kmp算法将rev去s中进行匹配,匹配结束后最终停留在rev(匹配串)的位置指针j即为最长后缀回文字符串的长度。举个🌰：字符串s为：”accbb”,其翻转字符串rev为：”bbcca”,进行一次kmp匹配后，最终匹配串的位置指针j的位置为2,故最长后缀回文字符串为”bb”。</p>
<ul>
<li><a href="https://vjudge.net/problem/UVA-11475">UVA-11475</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此题先求出最长后缀回文字符串,</span></span><br><span class="line"><span class="comment">在将原字符串的剩余部分进行翻转拼接在原字符串后即为正确答案。</span></span><br><span class="line"><span class="comment">如：&quot;accbb&quot;，最长后缀回文字符串为&quot;bb&quot;,则将&quot;acc&quot;翻转为&quot;cca&quot;拼接在原串后</span></span><br><span class="line"><span class="comment">得到&quot;accbbcca&quot;即使原串添加最少的字母成为回文字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">char</span> res[N];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(res+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i]=s[len-i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;res[i]!=res[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[j+<span class="number">1</span>]) j++;</span><br><span class="line">            ne[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;s[i]!=res[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i]==res[j+<span class="number">1</span>]) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>,s+<span class="number">1</span>,res+j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Manacher-算法（马拉车算法！？）"><a href="#Manacher-算法（马拉车算法！？）" class="headerlink" title="Manacher 算法（马拉车算法！？）"></a>Manacher 算法（马拉车算法！？）</h2><p>可以线性复杂度O(n)求出最长/所有回文子串,真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋,秒到家了！好吧，其实也没有多妙，又不能帮我上大分，饭桶一个😑。 </p>
<ul>
<li><strong>概念引出</strong>：</li>
</ul>
<ol>
<li>ManacherString：经过Manacher预处理的字符串，以下的概念都是基于ManasherString产生的。</li>
<li>回文半径和回文直径：因为处理后回文字符串的长度一定是奇数，所以回文半径是包括回文中心在内的回文子串的一半的长度，回文直径则是回文半径的2倍减1。</li>
<li>最右回文边界R：在遍历字符串时，每个字符遍历出的最长回文子串都会有个右边界，而R则是所有已知右边界中最靠右的位置，也就是说R的值是只增不减的。</li>
<li>回文中心C：取得当前R的第一次更新时的回文中心。由此可见R和C时伴生的。</li>
<li>半径数组：这个数组记录了原字符串中每一个字符对应的最长回文半径。</li>
</ol>
<ul>
<li><strong>算法流程如下：</strong></li>
</ul>
<ol>
<li>众所周知，偶回文串的处理相较于奇字符串是一大难题，该算法用来应对偶数字符串的方法就是预处理，这个预处理可以巧妙的让所有字符串都变为奇数回文串，其实就是将原字符串的首部和尾部以及每两个字符之间插入一个特殊字符，这一步预处理操作后的效果就是原字符串的长度从n改变成了2*n+1，这样可以遍历一次新串，以每个点为中心向两端扩展该奇回文字符串，最后维护一个有效的最大值即可。<br>&emsp;</li>
<li>R和C的初始值为-1，创建半径数组parr。(实际算法中的R是以i为中心的最回文右边界的值加1，同理，以i为回文中心的最长回文串的右端取不到i+parr[i]（parr[i]为i处的回文半径），只能向右扩展至i+parr[i]-1).<br>&emsp;</li>
<li>开始从下标 i = 0 去遍历ManacherString，每次维护最长回文子串的值即可。<br>&emsp;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ans;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>()*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//manacher处理后的字符串的长度为2*len-1</span></span><br><span class="line">    <span class="keyword">char</span>* tmp=<span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span>* parr=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对初始字符串数组进行处理，偶数位置0、2、4...变为&#x27;#&#x27;,奇数位置为原始字符</span></span><br><span class="line"><span class="comment">    如&quot;aba&quot;转化为&quot;#a#b#a#&quot;</span></span><br><span class="line"><span class="comment">    这样处理回文串起来只要从中心点向两侧扩展即可(这样相当于简化处理了原字符串的奇回文串和偶回文串)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) tmp[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> tmp[i]=s[(i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">-1</span>;<span class="comment">//初始化回文右边界的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> C=<span class="number">-1</span>;<span class="comment">//初始化回文中心的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i&lt;R时有两种情形,不确定属于哪种情形,故取二者的最小值赋值给i处的parr[i],即回文半径值,后续在进行扩展更新</span></span><br><span class="line">        <span class="comment">//2*c-i为i关于C的对称点</span></span><br><span class="line">        parr[i]=R&gt;i?<span class="built_in">min</span>(R-i,parr[<span class="number">2</span>*C-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+parr[i]&lt;len&amp;&amp;i-parr[i]&gt;<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i+parr[i]]==tmp[i-parr[i]]) parr[i]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+parr[i]&gt;R)<span class="comment">//此时的回文右边界超过原来的回文右边界则进行更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            R=i+parr[i];</span><br><span class="line">            C=i;<span class="comment">//回文中心的值也要更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parr[i]-1表示以该处为中心原始串的回文串的长度，减1是因为</span></span><br><span class="line"><span class="comment">        在tmp串(处理后的串)中以i处为中心的最长回文串的右边界为i+parr[i]-1,而不是i+parr[i]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(parr[i]<span class="number">-1</span>&gt;maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=parr[i]<span class="number">-1</span>;</span><br><span class="line">            ans=i;<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int k=i-(parr[i]-1);k&lt;=i+(parr[i]-1);k++)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%c&quot;,tmp[k]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);输出所有的回文子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    <span class="keyword">delete</span>[] parr;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//取消iostream的输入输出缓存,提高cin、cout的效率。</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">manacher</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="manacher与前缀回文、后缀回文串"><a href="#manacher与前缀回文、后缀回文串" class="headerlink" title="manacher与前缀回文、后缀回文串"></a>manacher与前缀回文、后缀回文串</h2><p>求前缀回文串、后缀回文串容易想到将字符串串翻转再进行kmp匹配，但是这样只能求出最大的前缀回文与后缀回文串，在很多情形下并不适用，因此这里记录一种用manache算法求出所有的前缀、后缀回文串。</p>
<ul>
<li>前面的步骤与一般的manacher算法无差，只是需要在处理出各点的回文半径之后进行一定的判断即可知道前缀、后缀回文字符串；比如在i点的回文半径为r（在manacher算法中真正的回文半径为parr[i]-1），若i-r等于0则表示该回文串包含了起始位置，也就说明该回文串为前缀回文串，且在原串中的回文串长度为回文半径r（parr[i]-1）；同理，如果i+r等于len-1则表示该回文串包含了末尾位置，也就说明该回文串为后缀回文串，且在原串中的回文串长度为回文半径r（parr[i]-1）。<br><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3613">HDU - 3613</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">int</span> val[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> fore[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ans;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>()*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//manacher处理后的字符串的长度为2*len-1</span></span><br><span class="line">    <span class="keyword">char</span>* tmp=<span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span>* parr=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对初始字符串数组进行处理，偶数位置0、2、4...变为&#x27;#&#x27;,奇数位置为原始字符</span></span><br><span class="line"><span class="comment">    如&quot;aba&quot;转化为&quot;#a#b#a#&quot;</span></span><br><span class="line"><span class="comment">    这样处理回文串起来只要从中心点向两侧扩展即可(这样相当于简化处理了原字符串的奇回文串和偶回文串)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) tmp[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> tmp[i]=s[(i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">-1</span>;<span class="comment">//初始化回文右边界的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> C=<span class="number">-1</span>;<span class="comment">//初始化回文中心的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i&lt;R时有两种情形,不确定属于哪种情形,故取二者的最小值赋值给i处的parr[i],即回文半径值,后续在进行扩展更新</span></span><br><span class="line">        <span class="comment">//2*c-i为i关于C的对称点</span></span><br><span class="line">        parr[i]=R&gt;i?<span class="built_in">min</span>(R-i,parr[<span class="number">2</span>*C-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+parr[i]&lt;len&amp;&amp;i-parr[i]&gt;<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i+parr[i]]==tmp[i-parr[i]]) parr[i]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+parr[i]&gt;R)<span class="comment">//此时的回文右边界超过原来的回文右边界则进行更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            R=i+parr[i];</span><br><span class="line">            C=i;<span class="comment">//回文中心的值也要更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parr[i]-1表示以该处为中心原始串的回文串的长度，减1是因为</span></span><br><span class="line"><span class="comment">        在tmp串(处理后的串)中以i处为中心的最长回文串的右边界为i+parr[i]-1,而不是i+parr[i]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(i-parr[i]+<span class="number">1</span>==<span class="number">0</span>) fore[parr[i]<span class="number">-1</span>]=<span class="number">1</span>;     <span class="comment">//前缀回文判断</span></span><br><span class="line">        <span class="keyword">if</span>(i+parr[i]<span class="number">-1</span>==len<span class="number">-1</span>) last[parr[i]<span class="number">-1</span>]=<span class="number">1</span>; <span class="comment">//后缀回文判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    <span class="keyword">delete</span>[] parr;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) cin&gt;&gt;val[i];</span><br><span class="line">    	<span class="built_in">memset</span>(fore,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(fore));</span><br><span class="line">    	<span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(last));</span><br><span class="line">    	string s;</span><br><span class="line">    	cin&gt;&gt;s;</span><br><span class="line">    	<span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    	sum[<span class="number">0</span>]=val[s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">  		&#123;</span><br><span class="line">  			sum[i]=sum[i<span class="number">-1</span>]+val[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  		&#125;</span><br><span class="line">    	<span class="built_in">manacher</span>(s);</span><br><span class="line">    	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//cout&lt;&lt;&quot;last1:&quot;&lt;&lt;last[1]&lt;&lt;endl;</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    		res+=(fore[i+<span class="number">1</span>]==<span class="number">1</span>)?sum[i]:<span class="number">0</span>;</span><br><span class="line">    		res+=(last[len-i<span class="number">-1</span>]==<span class="number">1</span>)?(sum[len<span class="number">-1</span>]-sum[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">    		ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">    	&#125;</span><br><span class="line">    	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="manacher算法求最长回文中间向两边不上升子串"><a href="#manacher算法求最长回文中间向两边不上升子串" class="headerlink" title="manacher算法求最长回文中间向两边不上升子串"></a>manacher算法求最长回文中间向两边不上升子串</h2><p>题目所求通俗来讲就是左半边非递减的回文子串，这算是具有更严格条件的manacher算法，但是却并不难实现，只需在判断回文子串的时候加上非递减的条件即可。</p>
<ul>
<li>因为本题的数据为整数，因此需要用未出现的整数（30）对字符串进行分隔（等同于’#’）。</li>
<li>判断非递减并非和后一个进行比较，应该和后两个进行比较，因为添加了分隔符（且分隔符比较时也满足，即30&lt;=30），如需要满足严格递增的条件可能需要分情况（分隔符向后比较和字符向后比较）进行特判。</li>
<li>求出来的parr数组不再是简单的回文半径，而是左半边非递减回文半径。</li>
</ul>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4513">HDU - 4513</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> ss[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ans;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=n*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//manacher处理后的字符串的长度为2*len-1</span></span><br><span class="line">    <span class="keyword">int</span>* tmp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>* parr=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) tmp[i]=<span class="number">30</span>;<span class="comment">//添加分隔符</span></span><br><span class="line">        <span class="keyword">else</span> tmp[i]=s[(i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">-1</span>;<span class="comment">//初始化回文右边界的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> C=<span class="number">-1</span>;<span class="comment">//初始化回文中心的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i&lt;R时有两种情形,不确定属于哪种情形,故取二者的最小值赋值给i处的parr[i],即回文半径值,后续在进行扩展更新</span></span><br><span class="line">        <span class="comment">//2*c-i为i关于C的对称点</span></span><br><span class="line">        parr[i]=R&gt;i?<span class="built_in">min</span>(R-i,parr[<span class="number">2</span>*C-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+parr[i]&lt;len&amp;&amp;i-parr[i]&gt;<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i+parr[i]]==tmp[i-parr[i]]&amp;&amp;tmp[i-parr[i]]&lt;=tmp[i-parr[i]+<span class="number">2</span>]) parr[i]++;<span class="comment">//加上非递减结合回文的条件进行判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+parr[i]&gt;R)<span class="comment">//此时的回文右边界超过原来的回文右边界则进行更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            R=i+parr[i];</span><br><span class="line">            C=i;<span class="comment">//回文中心的值也要更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(parr[i]<span class="number">-1</span>&gt;maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=parr[i]<span class="number">-1</span>;</span><br><span class="line">            ans=i;<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    <span class="keyword">delete</span>[] parr;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,i;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//取消iostream的输入输出缓存,提高cin、cout的效率。</span></span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;n;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    	&#123;</span><br><span class="line">    		cin&gt;&gt;ss[i];    </span><br><span class="line">    	&#125;</span><br><span class="line">    	cout&lt;&lt;<span class="built_in">manacher</span>(ss)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="manacher算法求出的回文串的在原串中的位置的转化"><a href="#manacher算法求出的回文串的在原串中的位置的转化" class="headerlink" title="manacher算法求出的回文串的在原串中的位置的转化"></a>manacher算法求出的回文串的在原串中的位置的转化</h2><ul>
<li>奇数为字符，偶数为分隔符，字符的位置除以2即为原串中的字符位置。</li>
<li>若该点的回文左边界为分隔符则加1除以2即为原串中回文左边界，若为字符，直接除以2即为原串中回文左边界</li>
<li>若该点的回文右边界为分隔符则减1除以2即为原串中回文右边界，若为字符，直接除以2即为原串中回文右边界</li>
</ul>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3294">HDU - 3294</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">int</span> l,r,dis;</span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">char</span> alpha[<span class="number">30</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> alpha[(c-<span class="string">&#x27;a&#x27;</span>-dis+<span class="number">26</span>)%<span class="number">26</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>()*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//manacher处理后的字符串的长度为2*len-1</span></span><br><span class="line">    <span class="keyword">char</span>* tmp=<span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span>* parr=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) tmp[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> tmp[i]=s[(i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">-1</span>;<span class="comment">//初始化回文右边界的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> C=<span class="number">-1</span>;<span class="comment">//初始化回文中心的值为-1</span></span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i&lt;R时有两种情形,不确定属于哪种情形,故取二者的最小值赋值给i处的parr[i],即回文半径值,后续在进行扩展更新</span></span><br><span class="line">        <span class="comment">//2*c-i为i关于C的对称点</span></span><br><span class="line">        parr[i]=R&gt;i?<span class="built_in">min</span>(R-i,parr[<span class="number">2</span>*C-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+parr[i]&lt;len&amp;&amp;i-parr[i]&gt;<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i+parr[i]]==tmp[i-parr[i]]) parr[i]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+parr[i]&gt;R)<span class="comment">//此时的回文右边界超过原来的回文右边界则进行更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            R=i+parr[i];</span><br><span class="line">            C=i;<span class="comment">//回文中心的值也要更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(parr[i]<span class="number">-1</span>&gt;maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=parr[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//奇数为字符，偶数为分隔符，字符的位置除以2即为原串中的字符位置。</span></span><br><span class="line">            <span class="comment">//若该点的回文左边界为分隔符则加1除以2即为原串中回文左边界，若为字符，直接除以2即为原串中回文左边界</span></span><br><span class="line">            <span class="comment">//若该点的回文→边界为分隔符则减1除以2即为原串中回文右边界，若为字符，直接除以2即为原串中回文右边界</span></span><br><span class="line">            <span class="keyword">if</span>((i-parr[i]+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) l=(i-parr[i]+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> l=(i-parr[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((i+parr[i]<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">0</span>) r=(i+parr[i]<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> r=(i+parr[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            ans=s.<span class="built_in">substr</span>(l,parr[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    <span class="keyword">delete</span>[] parr;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">    string s;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//取消iostream的输入输出缓存,提高cin、cout的效率。</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">    	dis=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) s[i]=<span class="built_in">get</span>(s[i]);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">manacher</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	cout&lt;&lt;l&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">        	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp统计前缀字符串出现次数"><a href="#kmp统计前缀字符串出现次数" class="headerlink" title="kmp统计前缀字符串出现次数"></a>kmp统计前缀字符串出现次数</h2><p>主要用到kmp中的next数组，遍历一次next数组，若next[m]=n，则表示长度为n的前缀字符串在序号为1-m的字符串（假设字符串从1开始编号）中出现一次，理解了这一层含义之后只需要遍历一次next数组，用map记录下前缀字符串的出现次数就行,因为遍历next数组的处理没有考虑到原始的前缀，故每种前缀的出现次数应加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">        m[j]++;<span class="comment">//长度为j的前缀字符串出现次数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AC自动机结合矩阵快速幂以及矩阵加速解决实际问题"><a href="#AC自动机结合矩阵快速幂以及矩阵加速解决实际问题" class="headerlink" title="AC自动机结合矩阵快速幂以及矩阵加速解决实际问题"></a>AC自动机结合矩阵快速幂以及矩阵加速解决实际问题</h2><ol>
<li><p>给定m个模板串，求出在规定字符类型中长度为n的不含任何一个模板串的字符串的个数。</p>
<p> 首先将所有模板串插入并建好字典树，总共得到tot+1个结点（包括根节点0），所有插入字符串的末尾结点的 num[] 值标记为1，即从根节点开始遍历末尾结点不能经过该点，否则会包含该模板串，后续利用 fail[] 数组将其余从根节点出发不能经过的点的 num[] 标记为1，处理条件为：若其失配指针出的结点不能经过，则该结点也不能经过，因为其失配指针处的位置表示其最长后缀，若其后缀为模板串不能被包含，则该串自己也不能被包含。建立矩阵模型，预处理初始矩阵m,m[i][j]表示从i结点到j结点且长度为1的字符串的个数，那么问题便简化为从根节点0到所有结点（包括自己）的长度为n的符合条件的字符串的个数。对矩阵m作n次幂（矩阵快速幂），得到的矩阵元素m’[i][j]则表示从i结点到j节点长度为n的不同方案数，在字典树中也就是长度为n的字符串个数，因为不符合条件的点已经被处理，那么最终答案就是m’[0][0]+…m’[0][tot]。</p>
</li>
</ol>
<hr>
<ul>
<li><a href="http://poj.org/problem?id=2778">POJ - 2778</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">110</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> num[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> fail[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">char</span> p[<span class="number">20</span>];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">200</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll mat[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="built_in">matrix</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix a,matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;=tot;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                c.mat[i][j]+=a.mat[i][k]*b.mat[k][j];</span><br><span class="line">                c.mat[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[root][mp[t[i]]]) node[root][mp[t[i]]]=++tot;</span><br><span class="line">        root=node[root][mp[t[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    num[root]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[u][i]) q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(num[fail[u]]==<span class="number">1</span>) num[u]=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node[u][i]) fail[node[u][i]]=node[fail[u]][i],q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">            <span class="keyword">else</span> node[u][i]=node[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_matrix</span><span class="params">(matrix &amp;a)</span><span class="comment">//得到初始矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!num[i]&amp;&amp;!num[node[i][j]])<span class="comment">//num值为1的结点不能要，因为该结点的状态表示一个不能被包含的串</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.mat[i][node[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(matrix &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) ans.mat[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(matrix ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans.mat[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,i;</span><br><span class="line">    ll n;</span><br><span class="line">    mp[<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    mp[<span class="string">&#x27;G&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">&#x27;C&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">&#x27;T&#x27;</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">        <span class="built_in">insert</span>(p);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,tot);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_fail</span>();<span class="comment">//以后建立字典树之后不get_fail()就是猪。</span></span><br><span class="line">    matrix a,ans;</span><br><span class="line">    <span class="built_in">get_matrix</span>(a);</span><br><span class="line">    <span class="built_in">get_ans</span>(ans);</span><br><span class="line">    <span class="comment">//print(a);</span></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=(sum+ans.mat[<span class="number">0</span>][i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>字符只能为小写英文字母，给定m个模板串，求出长度不超过n且包含任意一个模板串的字符串个数</p>
<p> 由上文已知可求出所有长度为n的字符串中所有不包含模板串的字符串，故此问题转化为所有字符串减去所有不包含模板串的字符串个数。总字符串数为26^1+…+26^n,即所有长度不超过n的字符串数，所有不包含模板串的字符串数为长度为1到长度为n的不包含模板串的字符串数之和。由于n过于庞大，直接求和会超时，因此需要用到矩阵加速。设f[n]=1 + 26^1 + 26^2 + … + 26^n，那么f[n]=26 * f[n-1]+1，则有{f[n]，1} = {f[n-1]，1} * [26 0;1 1]，所以{f[n],1}=[1,1] * [26 0;1 1]^n，即可求出长度不超过n的字符串数res=f[n]-1;由上文可知，将模板串插入字典树（设最大节点为tot）并经过预处理可得到一阶（不是一维）矩阵m[][]，而其n阶矩阵只能求出长度为n且不包含模板串的字符串个数，那么如何做到求和呢？只需要增加一维，第tot+1列全部为1，那么在乘积之后m[0][tot+1]即表示上一阶的所有不包含模板串个数+1（多了个1*1），最后求出m的n阶幂后，那么所有不包含模板串的字符串个数即为ans=m[0][0]+m[0][1]+…+m[0][tot+1]-1，那么res-ans即为最终答案！</p>
</li>
</ol>
<hr>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2243">HDU - 2243</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">40</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> fail[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll mat[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">matrix</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">matrix <span class="title">mul</span><span class="params">(matrix a,matrix b,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cnt;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                c.mat[i][j]+=(a.mat[i][k]*b.mat[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]) node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">        root=node[root][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    num[root]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[u][i]) q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(num[fail[u]]==<span class="number">1</span>) num[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node[u][i]) fail[node[u][i]]=node[fail[u]][i],q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">            <span class="keyword">else</span> node[u][i]=node[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_matrix</span><span class="params">(matrix &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!num[i]&amp;&amp;!num[node[i][j]])</span><br><span class="line">            &#123;</span><br><span class="line">                a.mat[i][node[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tot+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) a.mat[i][tot]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=tot;i++) </span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;=tot;j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         printf(&quot;%llu &quot;,a.mat[i][j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(matrix &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) ans.mat[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(matrix a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%llu &quot;</span>,a.mat[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,i;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%llu&quot;</span>,&amp;m,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(fail));</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get_fail</span>();</span><br><span class="line">        matrix a,ans,b,e;</span><br><span class="line">        b.mat[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">26</span>;</span><br><span class="line">        b.mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        b.mat[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        b.mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        e.mat[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        e.mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        ll x=n;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>) e=<span class="built_in">mul</span>(b,e,<span class="number">1</span>);</span><br><span class="line">            b=<span class="built_in">mul</span>(b,b,<span class="number">1</span>);</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res=e.mat[<span class="number">0</span>][<span class="number">0</span>]+e.mat[<span class="number">1</span>][<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;res:%llu\n&quot;,res);</span></span><br><span class="line">        <span class="built_in">get_matrix</span>(a);</span><br><span class="line">        <span class="built_in">get_ans</span>(ans);</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,ans.mat[0][0],ans.mat[1][1]);</span></span><br><span class="line">        x=n;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>) ans=<span class="built_in">mul</span>(ans,a,tot);</span><br><span class="line">            a=<span class="built_in">mul</span>(a,a,tot);</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// print(ans);</span></span><br><span class="line">        ll an=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=tot;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            an+=ans.mat[<span class="number">0</span>][i];</span><br><span class="line">            <span class="comment">// printf(&quot;%llu &quot;,ans.mat[0][i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,res-an+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="AC自动机与fail树"><a href="#AC自动机与fail树" class="headerlink" title="AC自动机与fail树"></a>AC自动机与fail树</h2><ul>
<li><p>如前文所写的未经优化的AC自动机可以AC掉简单情形下的多模式字符串匹配问题，但是会被特殊的模式串如”aaa…aaa”（设长度为n）卡掉不少的时间，因为这样的字符串在匹配时将会循环n次，时间复杂度将退化为单个KMP的 O(n*m)，因此建立fail树统一递归处理处理fail指针的转移状态会快很多。举个🌰：求’a’的出现次数即为’a’+”aa”+”aaa”+…的出现次数即可，那么从后往前依次递归处理即可，在字典树中”a”的出现次数可以转化为”a”的末尾结点的访问次数，因此在建立的fail树中DFS遍历一次便可以得到答案了。</p>
</li>
<li><p>借大佬画的字典树及fail树一用（不对应），老表上图：</p>
</li>
</ul>
<ol>
<li>字典树<br><img src="/images/loading.png" data-original="/2021/08/16/String/%E5%AD%97%E5%85%B8%E6%A0%91.png" alt="字典树"></li>
<li>fail树<br><img src="/images/loading.png" data-original="/2021/08/16/String/fail%E6%A0%91.png" alt="fail树"></li>
</ol>
<hr>
<p><a href="https://www.luogu.com.cn/problem/P5357">LG - P5357</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> ans[N],num[N],match[N],fail[N];</span><br><span class="line"><span class="keyword">int</span> node[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> tot,cnt;</span><br><span class="line"><span class="keyword">int</span> ne[N],head[N],to[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">char</span> p[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* t,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]) node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">        root=node[root][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    match[q]=root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[u][i]) q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node[u][i]) fail[node[u][i]]=node[fail[u]][i],q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">            <span class="keyword">else</span> node[u][i]=node[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=node[u][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ans[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[++cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        ans[u]+=ans[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(fail));</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(match));</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">            <span class="built_in">insert</span>(p,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get_fail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">query</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">add</span>(fail[i],i);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[match[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://www.cnblogs.com/Paul-Guderian/p/10217205.html/">https://www.cnblogs.com/Paul-Guderian/p/10217205.html\</a></p>
<h2 id="AC自动机-fail树-树状数组"><a href="#AC自动机-fail树-树状数组" class="headerlink" title="AC自动机+fail树+树状数组"></a>AC自动机+fail树+树状数组</h2><p>题意：给有小写字母构成的大小为3e5的树，有3e5个询问，每个询问给一个限制u和一个字符串t，求树上从根到节点u的路径构成的字符串中t串的出现次数。（询问串的长度总和不超过3e5）</p>
<ul>
<li>思路：将所有查询串全部插入字典树，记录每一个字符串的终止位置即查询编号（即第几个查询，方便输出答案），以及其属于哪一个限制u，该结点在对应限制上的访问次数也就是其出现次数。</li>
<li>若每次暴力暴力对文本串（也就是题中的限制）跑一次AC自动机，那么将是O(N*N)的时间复杂度，因此需要进行进一步优化。</li>
<li>利用字典树的每一个结点与其fail指针反向建立一棵fail树，首先让文本串在字典树上跑一次，每次访问到的结点，那么该结点的访问次数（该结点代表的字符串出现次数加1），那么最终某个结点的访问次数也就是以该结点为根节点的子树上所有结点次数之和。</li>
<li>这样便可以转化为单点修改及区间求和问题，因此用到树状数组的数据结构来进行巧妙的处理，首先通过dfs遍历对fail树每个结点按顺序编号，并数组记录下每个fail树上的结点对应的编号以及以其为根节点的子树中的最大编号（便于对该子树求和），直接上图理解。<br><a href="p1.jpg">p1</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;ask[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N],f[N];<span class="comment">//遇到同时存多个图的情况可以用多张邻接表来处理，不一定用链式前向星</span></span><br><span class="line"><span class="keyword">int</span> node[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N],tree[N],st[N],ed[N],fail[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> tot,dfs_num;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=dfs_num)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x]+=k;</span><br><span class="line">        x+=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=tree[x];</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//对fail树每个结点编一个dfs序，st[u]表示以该结点为跟的子树起始点的编号，ed[u]表示以该节点为跟的子树的最后一个编号（即最大编号）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=++dfs_num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:f[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=dfs_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    state=node[state][s[u]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="built_in">update</span>(st[state],<span class="number">1</span>);<span class="comment">//文本串遍利到该结点，该结点代表的字符串的次数加一，同时也需更新树状数组上的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:ask[u])<span class="comment">//fail树上结点u所代表的字符串出现次数即为该节点以及其子树所有结点出现次数之和</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[it.first]=<span class="built_in">getsum</span>(ed[it.second])-<span class="built_in">getsum</span>(st[it.second]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(it,u,state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(st[state],<span class="number">-1</span>);<span class="comment">//其所有子节点遍历完之后需要进行回溯，那么代表该结点不再被遍历到，该结点代表的字符串的次数减一，同时也需更新树状数组上的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]) node[root][t[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">        root=node[root][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//字符串插入字典树之后最终到达的结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[u][i]) q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node[u][i]) fail[node[u][i]]=node[fail[u]][i],q.<span class="built_in">push</span>(node[u][i]);</span><br><span class="line">            <span class="keyword">else</span> node[u][i]=node[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> qes;</span><br><span class="line">    cin&gt;&gt;qes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;str;</span><br><span class="line">        ask[x].<span class="built_in">push_back</span>(&#123;i,<span class="built_in">insert</span>(str)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_fail</span>();<span class="comment">//一定记得加上建立fail指针的过程，忘了太多次了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) f[fail[i]].<span class="built_in">push_back</span>(i);<span class="comment">//对于字典树上每个结点及其fail指针建立fail树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qes;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后缀数组求两个串的最长公共子串"><a href="#后缀数组求两个串的最长公共子串" class="headerlink" title="后缀数组求两个串的最长公共子串"></a>后缀数组求两个串的最长公共子串</h2><p>要求两个字符串的最长公共子串，首先将两个字符串进行拼接，利用后缀数组知识求出height数组，即最长公共字符串为某个height[i]的值，此时height[i]表示排序后排名为i和i-1的后缀字符串的最长前缀，因此需保证这两个后缀字符串的的起始位置分别在两个原字符串中，此时height[i]为两个字符串的公共子串。</p>
<p><font color="red">Pay attention：</font></p>
<ol>
<li><p>字符串不能直接拼接，需在二者之间加上分隔符，如 $!$ ，避免二者的公共子串从第一个字符串跨越至第二个字符串$aabaa$ $baab$，若不加 $!$ 分隔，则求出来的最长公共子串为$baab$，实则为$baa$。</p>
</li>
<li><p>可能在不同位置有相同的公共子串，若是要求输出公共子串不能直接输出，需要考虑去重。</p>
</li>
</ol>
<p><a href="https://vjudge.net/problem/UVA-760">UVA - 760</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N], s1[N], s2[N];</span><br><span class="line"><span class="keyword">int</span> y[N],x[N],c[N],sa[N],rk[N],height[N];</span><br><span class="line"><span class="keyword">int</span> n, m, len1, len2;<span class="comment">//n为合并后的总长度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        c[i]=x[i]=y[i]=sa[i]=rk[i]=height[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">122</span>; <span class="comment">//ascll(&#x27;z&#x27;)=122</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) c[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) ++c[x[i]=s[i]];<span class="comment">//桶</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; ++i) c[i]+=c[i<span class="number">-1</span>];<span class="comment">//求前缀和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; --i) sa[c[x[i]]--]=i;<span class="comment">//逆着标序 得到sa</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k&lt;&lt;=<span class="number">1</span>)&#123; <span class="comment">//倍增合并</span></span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=n-k+<span class="number">1</span>; i&lt;=n; ++i) y[++num]=i;<span class="comment">//没有第二关键字，排名在最前</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) <span class="keyword">if</span> (sa[i]&gt;k) y[++num]=sa[i]-k;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i) c[i]=<span class="number">0</span>;       <span class="comment">//初始化桶</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) ++c[x[i]];    <span class="comment">//桶</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; ++i) c[i]+=c[i<span class="number">-1</span>]; <span class="comment">//求前缀和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; --i) sa[c[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;<span class="comment">//第二关键字真正的排了序</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) y[i] = x[i];</span><br><span class="line">		x[sa[<span class="number">1</span>]] = num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) <span class="comment">//对第二关键字进行了简单的桶分类保存至x数组中</span></span><br><span class="line">			x[sa[i]]=(y[sa[i]]==y[sa[i<span class="number">-1</span>]] &amp;&amp; y[sa[i]+k]==y[sa[i<span class="number">-1</span>]+k]) ? num : ++num;</span><br><span class="line">		<span class="keyword">if</span> (num==n) <span class="keyword">break</span>;</span><br><span class="line">		m=num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for (int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, sa[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) rk[sa[i]]=i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//第一名height为0</span></span><br><span class="line">		<span class="keyword">if</span> (k) --k;   <span class="comment">//h[i]&gt;=h[i-1]-1;</span></span><br><span class="line">		<span class="keyword">int</span> j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span> (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k;</span><br><span class="line">		height[rk[i]]=k;<span class="comment">//h[i]=height[rk[i]];</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//	for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,height[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s1+<span class="number">1</span>, s2+<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        len1 = <span class="built_in">strlen</span>(s1+<span class="number">1</span>);</span><br><span class="line">        len2 = <span class="built_in">strlen</span>(s2+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;len1:%d len2:%d\n&quot;, len1, len2);</span></span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;++i) s[++n] = s1[i];</span><br><span class="line">        s[++n]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> now = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;++i) s[++n] = s2[i];</span><br><span class="line">        s[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">get_SA</span>();</span><br><span class="line">        <span class="built_in">get_height</span>();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s+1&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//for(int i=1;i&lt;=n;++i) printf(&quot; n:%d sa:%d %d\n&quot;, n, sa[i], height[i]);</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; ans)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i<span class="number">-1</span>] &lt; now &amp;&amp; sa[i] &gt; now) ans = <span class="built_in">max</span>(ans, height[i]);</span><br><span class="line">                <span class="keyword">if</span>(sa[i] &lt; now &amp;&amp; sa[i<span class="number">-1</span>] &gt; now) ans = <span class="built_in">max</span>(ans, height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后缀数组求多个串的最长公共子串"><a href="#后缀数组求多个串的最长公共子串" class="headerlink" title="后缀数组求多个串的最长公共子串"></a>后缀数组求多个串的最长公共子串</h2><p>将所有字符串进行拼接，每两个字符串之间用分隔符分隔，二分最长公共子串的长度（考虑好二分的上下边界），并利用后缀数组的知识判断其是否为所有字符串的公共子串。值得注意的是：分隔符不能相同，否则在某些情形下求出的最长公共子串会出现错误，比如都用0分隔：$c0abc0a$,那么在一半的模板串中共同出现的最长子串为c0a（模板串为$c$、$abc$、$a$）。</p>
<ul>
<li>判断：从头开始遍历height数组并根据二分值对其畸形分组，即大于等于x的即为一组，那么该组中的后缀字符串具有长度为x的公共子串，若这些后缀字符串在所有字符串中均有分布，则表示该长度为x的公共子串是所有字符串的公共子串。那么如何判断该后缀字符串属于哪个字符串呢？输入字符串的时候预处理一下即可，用数组kind[]将每个字符串边界位置记录下来即可，也就是分隔符的位置，第一个分隔符即为第一个字符串的右边界，以此类推…若某个后缀字符串的编号为p，只需遍历一遍kind数组，若$ kind[j-1]&lt;p&lt;kind[j] $，那么说明该后缀字符串属于第 j 个字符串。</li>
</ul>
<ul>
<li>记录：遇到不符合分组条件的则进行一次判断，若该分组的后缀字符串分布在所有字符串中，则表示所有字符串有该共同子串。那么记录某一个后缀字符串的起始位置放于数组 v[] 中，只要在外部维护公共子串的长度，那么就能输出最长最长公共子串了。这里需要从v[1]开始存储，因为可能有多个符合条件的子串，故可能有多个位置，v[0]记录符合条件的子串数目，因为是对height数组顺序遍历处理得来的结果，所以顺序输出即为字典序结果。</li>
</ul>
<p><a href="https://vjudge.net/problem/POJ-3080">POJ - 3080</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rak[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> kind[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"><span class="keyword">int</span> bound,cas;<span class="comment">//cas为字符串数数目</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//printf(&quot;x: %d\n&quot;,x);</span></span><br><span class="line">    <span class="keyword">int</span>  i,j;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p1=sa[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> p2=sa[i];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=cas;j++)<span class="comment">//判断属于哪个字符串并计数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p1&gt;kind[j<span class="number">-1</span>]&amp;&amp;p1&lt;kind[j]) cnt+=(vis[j]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>),vis[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;kind:%d %d %d\n&quot;,kind[j-1],kind[j],cnt);</span></span><br><span class="line">                <span class="keyword">if</span>(p2&gt;kind[j<span class="number">-1</span>]&amp;&amp;p2&lt;kind[j]) cnt+=(vis[j]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>),vis[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;kind:%d %d %d\n&quot;,kind[j-1],kind[j],cnt);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d %d\n&quot;,p1,p2,cnt);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=cas)<span class="comment">//所有子串具有该长为x的共同子串</span></span><br><span class="line">            &#123;</span><br><span class="line">                v[++size]=sa[i<span class="number">-1</span>];<span class="comment">//记录后缀字符串的起始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=cas)</span><br><span class="line">    &#123;</span><br><span class="line">        v[++size]=sa[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size)</span><br><span class="line">    &#123;</span><br><span class="line">        v[<span class="number">0</span>]=size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,ans,maxn,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cas);</span><br><span class="line">        n=<span class="number">1</span>;</span><br><span class="line">        maxn=INF;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cas;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">            <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line">            maxn=<span class="built_in">min</span>(maxn,len);</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cal[n++]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cal[n]=<span class="string">&#x27;#&#x27;</span>+i;<span class="comment">//分隔多个字符串的分隔符不能相同，否则会出现如下情形</span></span><br><span class="line">                         <span class="comment">//c*abc*a,那么在一半的模板串中共同出现的最长子串为&quot;c*a&quot;。</span></span><br><span class="line">            kind[i]=n;<span class="comment">//记录第i个字符串的右边界</span></span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        cal[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        n-=<span class="number">2</span>;<span class="comment">//拼接后的字符串的最终长度，不包括&#x27;\0&#x27;</span></span><br><span class="line">        <span class="comment">// for(i=0;i&lt;=cas;i++) printf(&quot;%d &quot;,kind[i]);</span></span><br><span class="line">        <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">         <span class="comment">//printf(&quot;%s\n&quot;,s+1);</span></span><br><span class="line">        <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">300</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high=maxn;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,maxn);</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                ans=mid;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// for(i=1;i&lt;=v[0];i++) printf(&quot;%d &quot;,v[i]);</span></span><br><span class="line">        <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;no significant commonalities\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">            <span class="keyword">for</span>(j=v[<span class="number">1</span>];j&lt;v[<span class="number">1</span>]+ans;j++)<span class="comment">//题目只要求输出字典序最小的一个，故起始位置为v[1]，后面可能记录了其它最长子串的起始位置，但字典序不是最小，故不输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,cal[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="后缀数组-RMQ（区间最值问题）"><a href="#后缀数组-RMQ（区间最值问题）" class="headerlink" title="后缀数组+RMQ（区间最值问题）"></a>后缀数组+RMQ（区间最值问题）</h2><p>问题给出n个字符串，要求某两个字符串的最长公共前缀。</p>
<ol>
<li>首先将所有字符串用不相同且未曾出现过的字符进行拼接起来，记录每个字符串的起始位置在拼接后的字符串中的位置编号，建立后缀数组。</li>
<li>利用rk数组可知道两个待查询字符串对应的后缀字符串所在的排名 p1、p2（假设 p1 &lt; p2 ），即求排名为 p1 、p2 的后缀字符串的最长公共前缀lcp(p1,p2),也就是     height[p1+1] 至 height[p2] 中的最小值，由此可以转化为 $p_1+1 - p_2$ 区间内的最小值问题（RMQ）。</li>
</ol>
<p><a href="https://vjudge.net/problem/UVA-12338">UVA - 12338</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rk[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rk[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rk[i]=rk[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> llen[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">30</span>];</span><br><span class="line"><span class="comment">//我们设二维数组dp[i][j]表示从第i位开始连续$2^j$</span></span><br><span class="line"><span class="comment">//个数中的最小值。例如dp[2][1]就表示从第二位数开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），dp[i][0]就表示第i个数字本身。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq_init</span><span class="params">()</span> <span class="comment">//RMQ初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;=n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]); <span class="comment">//i + (1 &lt;&lt; (j - 1))</span></span><br><span class="line">    <span class="comment">//左移操作符的优先级小于加号的优先级</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//查询排名为l-1、r的后缀字符串的lcp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log2</span>(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[l][k], dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,ans,t,cs,q,x,y,cas;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(cs=<span class="number">1</span>;cs&lt;=t;cs++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cas);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cas;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos[i]=n;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">            <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line">            llen[i]=len;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cal[n++]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cal[n]=<span class="number">150</span>+i;<span class="comment">//分隔多个字符串的分隔符不能相同，否则会出现如下情形</span></span><br><span class="line">                         <span class="comment">//c*abc*a,那么在一半的模板串中共同出现的最长子串为&quot;c*a&quot;。</span></span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        cal[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        n-=<span class="number">2</span>;<span class="comment">//拼接后的字符串的最终长度，不包括&#x27;\0&#x27;</span></span><br><span class="line">        <span class="comment">// for(i=0;i&lt;=cas;i++) printf(&quot;%d &quot;,kind[i]);</span></span><br><span class="line">        <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">         <span class="comment">//printf(&quot;%s\n&quot;,s+1);</span></span><br><span class="line">        <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">1000000</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,cs);</span><br><span class="line">        <span class="built_in">rmq_init</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=INF;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="comment">//printf(&quot;pos:%d %d\n&quot;,pos[x],pos[y]);</span></span><br><span class="line">            <span class="keyword">int</span> p1=<span class="built_in">min</span>(rk[pos[x]],rk[pos[y]]);</span><br><span class="line">            <span class="keyword">int</span> p2=<span class="built_in">max</span>(rk[pos[x]],rk[pos[y]]);</span><br><span class="line">            <span class="keyword">if</span>(x==y) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,llen[x]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">rmq</span>(p1+<span class="number">1</span>,p2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀数组求某字符串中排名为k的子串"><a href="#后缀数组求某字符串中排名为k的子串" class="headerlink" title="后缀数组求某字符串中排名为k的子串"></a>后缀数组求某字符串中排名为k的子串</h2><p>求排名首先想到后缀数组对后缀字符串的排序，而后缀字符串的前缀即为子串，对后缀字符串排序即为对子串排序，只不过会有重复的子串穿插其中，那么从排名为1的后缀字符串开始遍历时只需减去height[i]的值即可得到目前的正确排名数n，判断是否大于等于k即可知道该排名为k的子串是否在该后缀字符串中，根据二者的关系输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],wss[N],rk[N],height[N],cal[N],n,sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p) &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rk[i++]]=k)</span><br><span class="line">     <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)rk[i]=rk[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,ans,k,cs,t,cnt,l;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i];i++) cal[n++]=s[i];</span><br><span class="line">    cal[n]=<span class="number">0</span>;</span><br><span class="line">    n-=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">da</span>(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">300</span>);</span><br><span class="line">    <span class="built_in">calheight</span>(cal+<span class="number">1</span>,sa,n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len=n-sa[i]+<span class="number">1</span>-height[i];</span><br><span class="line">            cnt+=len;</span><br><span class="line">            l=cnt-len;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=k-l;</span><br><span class="line">                <span class="keyword">int</span> end=sa[i]+height[i]+x<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(j=sa[i];j&lt;=end;j++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,cal[j]);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>kmp</tag>
        <tag>Manacher</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking</title>
    <url>/2021/10/31/Thinking/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“ 妙蛙！”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="凑平方数"><a href="#凑平方数" class="headerlink" title="凑平方数"></a>凑平方数</h2><ul>
<li><p><a href="https://www.lanqiao.cn/problems/653/learning/">凑平方数</a>：把 0 ~ 9 这 10 个数字，分成多个组，每个组恰好是一个平方数，问共有多少种方案？（0可以但单独作为平方数，但是不能作为多位数字的开始）</p>
</li>
<li><p>思路：一开始想的是直接将这十个数字进行全排列，然后在对这个排列进行检查，然后发现复杂度是1e9起步，着实是不敢跑了，上次跑个1e9电脑蓝屏了都😑！最后还是发现，做这种题目一定是要看数据或者题目条件的特征是否可以从中筛选出符合条件的数据从而减少数据量；可以发现，能够符合条件的数的组合一定是平方数，这样我们只需要筛选出平方数再进行检查即可，但是发现还是会有1e5的数据量，用dfs搜索的话复杂度还是吃不消的，然后再仔细看条件，发现，其中的平方数是不能带重复数字的，那么便又能进一步筛选出符合条件的数据，最终发现$1e^{10}$的数据范围内也就611个不重复数字的平方数，最后再对这些数据进行搜索，那么问题也就迎刃而解了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">vector&lt;ll&gt; num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheek</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//记录数字的状态，初始时全部标记为0</span></span><br><span class="line">    ll status=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) &#123;</span><br><span class="line">        status=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//标记最低位即第0位为一</span></span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="comment">//每一位比较状态，已被使用不记录</span></span><br><span class="line">        <span class="keyword">if</span>((status &amp; ( <span class="number">1</span>&lt;&lt; (x%<span class="number">10</span>) ) )!=<span class="number">0</span> )<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//记录数字使用情况</span></span><br><span class="line">        status|=(<span class="number">1</span>&lt;&lt;(x%<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//消掉各位</span></span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续处理新的各位，直到全部消掉</span></span><br><span class="line">    <span class="comment">//添加vector中</span></span><br><span class="line">    num.<span class="built_in">push_back</span>(status);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=x;i&lt;num.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((num[i]&amp;y)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i+<span class="number">1</span>,num[i]|y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//枚举算出满足题意的平方数并存储其数位使用情况的状态</span></span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cheek</span>(i*i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num.<span class="built_in">size</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//用深度按顺序组合预处理的平方数</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="修改数组之不重复数组（并查集）"><a href="#修改数组之不重复数组（并查集）" class="headerlink" title="修改数组之不重复数组（并查集）"></a>修改数组之不重复数组（并查集）</h2><ul>
<li><p>题目来源：<a href="https://www.lanqiao.cn/problems/185/learning/">修改数组</a></p>
</li>
<li><p>题目描述：给定一个数组A，其中会有重复的数，从第二个数开始，如果前面没有与之相同的数，那么这个数不需要变化，如果有，那么每次加1判断前面是否有重复的数，知道整个数组都满足该条件，输出最后的数组。</p>
</li>
<li><p>思路：将出现的数d与其下一个数d+1链接在同一个并查集中，d+1为d的祖先，要想知道一个数应该修改成哪一个数，只需从并查集的底部查找起，找到最顶端的数即为满足条件的数（中间会存在路径压缩，因此时间复杂度并不会很高），再将该数与比它大1的数链接起来，重复以上步骤就能得到答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x,y,z) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;<span class="meta-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="meta-string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//#x直接输出传入的变量名</span></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> ffa=<span class="built_in">find</span>(x);</span><br><span class="line">		fa[ffa]=ffa+<span class="number">1</span>;</span><br><span class="line">		ans[i]=ffa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="长度为n的数组中的最大子段积"><a href="#长度为n的数组中的最大子段积" class="headerlink" title="长度为n的数组中的最大子段积"></a>长度为n的数组中的最大子段积</h2><ul>
<li>对于一个数组中的所有子段，毫无疑问其具有连续性规律，也就是说对于任一子段，其都可以由原数组从首部或者尾部去掉任意个元素后得到</li>
<li>对于一个不含0元素的数组：<ul>
<li>那么假设原数组所有元素的乘积为正数，那么显然这时候的乘积是最大的，即为答案</li>
<li>若原数组所有元素的乘积为负数，那么此时删掉一个负数即可得到最大子段积，有最开始得到的推出所有子段的规律可知，我们只需分别从左右两端往内部寻找到第一个负数将这一段的元素全部删去即可得到最大子段积（二者取最大即可）</li>
</ul>
</li>
<li>若原数组包含元素0，我们只需以0作为间隔，将间隔之间的元素作为原数组，这样原数组便不在包含元素0，再以上述方法进行查找即可（此时需要将找到的最大值与0进行比较（如 0 -1 0 -1000 0）这时找到的最大值会是 -1 -1000，如果子段可以为空的就没必要比较了，可以为空的话最大值可以取到0）<h2 id="一个集合中任取两个数的乘积之和"><a href="#一个集合中任取两个数的乘积之和" class="headerlink" title="一个集合中任取两个数的乘积之和"></a>一个集合中任取两个数的乘积之和</h2>在某种情形下可用于后缀数组的height数组在分组后求解方案数，如相同前缀字符数大于等于k的子字符串组合数有多少种。<br>一般处理方法是O(n^2)的时间复杂度枚举所有可能的组合，但是这种巧妙的处理方法使得时间复杂度降为O(n)。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i,n,res,ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=a[i];</span><br><span class="line">        ans=ans+res*a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最小生成树-随机数-素数"><a href="#最小生成树-随机数-素数" class="headerlink" title="最小生成树+随机数+素数"></a>最小生成树+随机数+素数</h2><p>给定n个点，利用题目给定的代码生成n个L,R以内的随机数表示n个点值，而i，j间的权值为gcd($a_i$,$a_j$),求使n个点的连通的最小花费。</p>
<ul>
<li>首先看到最小、gcd等字眼应该想到素数，素数和任何数的gcd都是1，那么只要有一个素数，那么该素数点与其余所有点连接即既满足连通又满足最小花费n-1。</li>
<li>什么时候会出现素数？打印一张素数表就能发现：素数的分布十分密集，因此只要生成的随机数目超过10个（试出来的）就一定会出现一个素数，所以只要分情况讨论即可。</li>
<li>当点数小于10个时，暴力枚举出所有的边，利用kruskal算法即能算出最小生成树的花费。</li>
<li>值得注意的是如果L=R，那么所有点只能取到一个数L，所以答案为L*（n-1），这一点需要特判。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">int</span> n,L,R,a[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> seed;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">xorshift64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x=seed;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">13</span>;</span><br><span class="line">    x^=x&gt;&gt;<span class="number">7</span>;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">17</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gen</span><span class="params">()</span><span class="comment">//生成随机数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">xorshift64</span>()%(R-L+<span class="number">1</span>)+L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        u=a;</span><br><span class="line">        v=b;</span><br><span class="line">        val=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;point&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%llu&quot;</span>,&amp;n,&amp;L,&amp;R,&amp;seed);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">gen</span>();</span><br><span class="line">    <span class="keyword">if</span>(L==R)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">1LL</span>*(n<span class="number">-1</span>)*L);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;   </span><br><span class="line">                v.<span class="built_in">push_back</span>(<span class="built_in">point</span>(i,j,<span class="built_in">gcd</span>(a[i],a[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> len=v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)<span class="comment">///最小生成树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">find</span>(v[i].u);</span><br><span class="line">            <span class="keyword">int</span> y=<span class="built_in">find</span>(v[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">            ans+=v[i].val;</span><br><span class="line">            fa[x]=y;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一个字符串的子串与另一个字符串的子序列匹配问题"><a href="#一个字符串的子串与另一个字符串的子序列匹配问题" class="headerlink" title="一个字符串的子串与另一个字符串的子序列匹配问题"></a>一个字符串的子串与另一个字符串的子序列匹配问题</h2><p>显而易见，子串的约束条件比子序列的约束条件更加严格，因此可以考虑枚举子串而去查找合适的子序列，枚举子序列是不现实的。</p>
<ul>
<li>双指针枚举子串，这样枚举的时候子串是有一定的规律的，当左指针i固定，右指针j向右移动时，新的子串是在原子串的基础上加上一个字符，因此查找对应的子序列时只需设定另一个指针point顺序遍历一遍字符串直到找到该字符便停止即可。</li>
<li>用字符串记录符合条件的子串会超内存，可以用hash值记录。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">const</span> ull base=<span class="number">13331</span>;</span><br><span class="line"><span class="keyword">const</span> ull mod=<span class="number">0xffffffffffffffff</span>;</span><br><span class="line">ull hs[N],pw[N];</span><br><span class="line"><span class="comment">// unordered_map&lt;ull,bool&gt; mp;</span></span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hs[r]-hs[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ull v[N*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line">    string s,p;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    p=<span class="string">&quot; &quot;</span>+p;</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) hs[i]=(hs[i<span class="number">-1</span>]*base%mod+p[i])%mod;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;get(4,5)&lt;&lt;&quot; &quot;&lt;&lt;get(5,6)&lt;&lt;endl; </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> point=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//ull has=0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(point&lt;=n&amp;&amp;s[point]!=p[j]) point++;</span><br><span class="line">            <span class="keyword">if</span>(point&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p.substr(i,j-i+1)&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            ull tmp=<span class="built_in">get</span>(i,j);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">            v[tot++]=tmp;</span><br><span class="line">            point++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto it:mp) cout&lt;&lt;it.first&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">sort</span>(v,v+tot);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">unique</span>(v,v+tot)-v&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;mp.size()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bitset巧妙处理n个数可能构成的和"><a href="#bitset巧妙处理n个数可能构成的和" class="headerlink" title="bitset巧妙处理n个数可能构成的和"></a>bitset巧妙处理n个数可能构成的和</h2><ul>
<li>给定n个数，需要知道其中任意个数的和能够构成的数有哪些，按照一般的处理方法复杂度为$C_n^0+C_n^1+C_n^2+…+C_n^n$即$2^n$，这样的复杂度属实是不能接受的，但是用bitset却可以通过移位运算以及逻辑运算可以快速的解决。</li>
<li>首先定义bitset&lt;1e9&gt; bit,其每一位上的数若为0则表示该数没有出现，若为1作为表示该数出现过，并且两个数的加法运算实际就是bitset的移位操作，如2+5实际就是bitset的第二位的位置向左移5位，此时第七位置1表示7出现。因此从n个数中取任意个数的和能够构成的数值也可以利用这样的方式求得：先将第一个的数的位数置1，后续每读入一个数x就将原bitset左移x位再与原bitset进行逻辑或运算即取并集，然后将数x的位置1，最后得到的bitset即为n个数取任意个数的和能够表示的数。</li>
<li>这样的方法当数据较大时需要占用很大的内存，可能就不太适用了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">bitset&lt;1000000&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	bit.<span class="built_in">reset</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) bit[a[i]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			bit=bit|bit&lt;&lt;a[i];</span><br><span class="line">			bit[a[i]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(int i=0;i&lt;1000000;i++)</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	if(bit[i]==1) cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>题意：n个冰激凌，给出冰激凌的融化速度mv，小明吃冰激凌的速度ev，问小明怎么吃能够使得吃到的冰激凌最少，最少为多少？</p>
<ul>
<li>二分最终进过的时间mid，那么可以计算出通过融化速度计算出小明最终吃到的冰激凌的质量，再利用吃冰激凌的速度算出小明吃冰激凌的时间t，如果t &gt; mid那么说明最终经历的时间应该更长，low=mid；如果t &lt; mid那么说明最终经历的时间应该更长，high=mid。</li>
<li>注意点：二分时更改有效域时只能为（low=mid || high=mid）,不能像整数域的二分一样写成（low=mid+1 || high=mid-1），因为考虑到结果的精度为1e^6在1以内，那样修改二分区域会导致错过正确结果。</li>
<li>二分时尽量用for循环（比如100次）来控制精度，这样既能直观的计算时间复杂度也能很好的通过改变二分次数来控制想要的精度。</li>
<li>同样也可以二分小明吃到的冰激凌质量<br><a href="https://codeforces.com/gym/102860">二分</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> g[N],n,mv,ev;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> res=<span class="number">0</span>;<span class="comment">//记录小明吃到的冰激凌总数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mid*mv&gt;g[i]) <span class="keyword">continue</span>;<span class="comment">//如果融化的质量大于那一堆的冰激凌质量，小明吃不到</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			res+=(g[i]-mv*mid);<span class="comment">//否则二者的插值为小明吃到的冰激凌</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res/ev&gt;mid) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//如果小明吃冰激凌的时间大于该时间，那么时间答案应该大于改时间，二分下界low改为mid</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;mv&gt;&gt;ev;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;cin&gt;&gt;g[i];sum+=g[i];&#125;</span><br><span class="line">	<span class="keyword">double</span> low=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">double</span> high=(<span class="keyword">double</span>)sum/mv;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++)<span class="comment">//浮点数的二分尽量用循环来控制二分次数</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">double</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			low= mid;<span class="comment">//不能low = mid + 1,因为是浮点数的二分</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			high= mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7f&quot;</span>, low * ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="巧妙的思维变换-优先队列-多重集（multiset）"><a href="#巧妙的思维变换-优先队列-多重集（multiset）" class="headerlink" title="巧妙的思维变换+优先队列/多重集（multiset）"></a>巧妙的思维变换+优先队列/多重集（multiset）</h2><p>题意：有n个政治家，每个人身上有现金m以及实现政治目标另需的金额p，现在你是大盗罗宾逊，对于每个政治家你可以选择偷钱或者资助他，资助之后他可以包庇你一次偷钱的罪行，问你最多可以偷多少个政治家？</p>
<p>核心思想如下：</p>
<pre><code>前提：可以证明如果能够偷k个人收买k个人那么一定能够偷k-1个人收买k-1个人。
例如目前假设已经选定了2k个人，即验证能否偷k个人，剩下的n-2k个人已经无关，设被偷的k个人为集合A，被收买的k个为集合B，
假设现在偷A的人偷到了x元，收买B的人要花y元，设z=x-y，我们试图增大z，直到z不小于0（实际上等价于最大化z再检查z是否不小于0）即表明答案不小于k，由于2k个人已经被固定，我们能做的就靠只有交换AB阵营的人，以期偷的钱够收买对应数量的政治家。
关于交换的有公式：
设A里有个人叫r他有a元，收买他需要b元；B里有个人叫s,他有c元，收买他需要d元， 
然后我现在不“偷r收买s”了，我改成“偷s收买r”，那么z就会更新为z+(c+d)-(a+b)。
定义tot[i]=m[i]+p[i],这表明如果tot[s]=（c+d)&gt;tot[r]=(a+b)，那么偷s收买r比偷r收买s更优，也就是说tot值大的一定是适合偷而不是收买多少的。
因此我们可以计算处每个人的tot按照从大到小排序，对tot值较大的人偷k个，对tot值小的进行收买。由于不能对同一个人进行偷与收买，因此需要对偷与收买的人群划分界限（因为不能确定，所以只能枚举），在界限左边选k个人进行偷取（因为tot值大），在分水岭右边选k个人进行收买，那么偷取的人自然是k个m最大的，而收买的自然是k个p最小的，如果存在一个界限使得界限左边偷k个人的钱大于界限右边收买k个人的钱那么偷k个人便是可以做到的。
</code></pre>
<ul>
<li>fornt_max[i]:前i个人中取k个最大m值的和（前i个人中取k个m值最大的人进行偷取），back_min[i]:第i个人及以后k个最小p值的和（后i个人中取k个p值最小的人进行收买），只要存在某个i使得fornt_max[i]&gt;=back_min[i+1],那么便能说明偷k个人是成立的。fornt_max[i]的求法可以先将前k个人的m值压入优先队列，求和即为fornt_max[k]的值，以后每增加一个人如果其m值大小优先队列中的最小值，说明其值在前k名，那么弹出优先队列队首，并将值压入优先队列，front_max[i]=front_max[i-1]-pq_max.top()+x，否则front_max[i]=front_max[i-1]。<br><a href="https://codeforces.com/gym/103102/problem/L">Neo-Robin Hood</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll front_max[N],back_min[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; pq_max;<span class="comment">//最小优先队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq_min;<span class="comment">//最大优先队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> p;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;pol[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Pol a,Pol b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&gt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//特判0，否则会越界</span></span><br><span class="line">	<span class="built_in">memset</span>(front_max,<span class="number">0LL</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(front_max));</span><br><span class="line">	<span class="built_in">memset</span>(back_min,<span class="number">0LL</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(back_min));</span><br><span class="line">	<span class="keyword">while</span>(pq_max.<span class="built_in">size</span>()) pq_max.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">int</span> st=k,ed=n-k+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) front_max[st]+=pol[i].m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) pq_max.<span class="built_in">push</span>(pol[i].m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=st+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x=pol[i].m;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;pq_max.<span class="built_in">top</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			front_max[i]=front_max[i<span class="number">-1</span>]-pq_max.<span class="built_in">top</span>()+x;</span><br><span class="line">			pq_max.<span class="built_in">pop</span>();</span><br><span class="line">			pq_max.<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> front_max[i]=front_max[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pq_min.<span class="built_in">size</span>()) pq_min.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=ed;i&lt;=n;i++) back_min[ed]+=pol[i].p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=ed;i&lt;=n;i++) pq_min.<span class="built_in">push</span>(pol[i].p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=ed<span class="number">-1</span>;i&gt;=st+<span class="number">1</span>;i--)<span class="comment">//当len=0时，优先队列中没有元素，此时pop会产生越界错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x=pol[i].p;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;pq_min.<span class="built_in">top</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			back_min[i]=back_min[i+<span class="number">1</span>]-pq_min.<span class="built_in">top</span>()+x;</span><br><span class="line">			pq_min.<span class="built_in">pop</span>();</span><br><span class="line">			pq_min.<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> back_min[i]=back_min[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=st;i&lt;=ed<span class="number">-1</span>;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(front_max[i]&gt;=back_min[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;pol[i].m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;cin&gt;&gt;pol[i].p;pol[i].val=pol[i].p+pol[i].m;&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(pol+<span class="number">1</span>,pol+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">int</span> low=<span class="number">0</span>,high=n/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			low=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="交互思维题"><a href="#交互思维题" class="headerlink" title="交互思维题"></a>交互思维题</h2><p>题意：给出1到n这n个数，然后奇数按某种顺序分到o数组，偶数按某种顺序分到e数组，你每次可以询问e数组中第i个和o数组中第j个的大小情况，查询结束后输出结果。（查询次数最多30 000次，n&lt;=10000，时限：10s）</p>
<ul>
<li>常规思路：将偶数数组中的每个数和奇数组中的每个数进行一次比较，记录双方分别记录该数比多少个数大，对于偶数，如果其比x个数大，那么答案就是x * 2，对于奇数，答案就是x * 2 + 1。<br>但是询问次数为$（n/2）^2$，显然需要对次数进行优化。</li>
<li>误区：n只有10000，而时限给了10s，因此时间复杂度可以搞到很大，所以不需要担心超时的问题，本题的限制主要在于询问次数，因此重要的是考虑如何拿时间换次数，或者说设计优秀的算法来减少询问次数。</li>
<li>现在考虑偶数组第一个元素与奇数组所有元素进行一次比较，比较之后能够获得有效信息有：<ol>
<li>该元素的值</li>
<li>奇数组中所有的元素和的该元素的大小关系</li>
</ol>
</li>
<li>有了这两个信息之后便可以进一步对奇数组中的元素限定范围，比如：如果该元素为x，奇数组中的某个元素若大于它，那么其范围为[x+1,n]（假设n为奇数），反之则为[1,x-1]。<br>划定范围也同样能够应用到偶数组上，这样每个元素都有一个范围，通过若干次的比较之后范围会被无限的缩小。</li>
<li>假设到了这样一种情形：偶数组中某个值的范围和奇数组中的某个元素的范围没有交集，那么这样我们是不需要进行询问是能够知道二者的大小关系的，因此只要通过比较缩小范围之后其中会产生这样的元素对，那么询问次数就被降下来了；反之，如果有交集，那么二者之间的大小关系是不能确定的，那么是需要进行询问的。</li>
<li>对于某个偶数组的元素，再起和奇数组的所有元素进行比较之后，那么其值是可以确定的，那么此时还可以集合奇数组中每个元素与其的大小关系（比较时存下来）对于奇数组每个元素的取值范围进行进一步的更新，当取值范围更精确、范围更小时那么是可以减少询问次数的，否则会次数会超（我应该是知道的）。<br><a href="https://codeforces.com/gym/101630">CF - 101630</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> o_rk[N],e_rk[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;e[N],o[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(node a,node b)</span><span class="comment">//区间相交判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.r&lt;b.l||a.l&gt;b.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) &#123;e[i].l=<span class="number">2</span>,e[i].r=((n&amp;<span class="number">1</span>)==<span class="number">0</span>)?n:n<span class="number">-1</span>;&#125;<span class="comment">//偶数组赋初始范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;i++) &#123;o[i].l=<span class="number">1</span>,o[i].r=((n&amp;<span class="number">1</span>)==<span class="number">0</span>)?n<span class="number">-1</span>:n;&#125;<span class="comment">//奇数组赋厨师范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">intersect</span>(e[i],o[j]))<span class="comment">//判断区间是否相交</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                cin&gt;&gt;s[j];</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;&lt;&#x27;</span>)<span class="comment">//偶小于奇</span></span><br><span class="line">                &#123;</span><br><span class="line">                    o_rk[j]++;<span class="comment">//奇数组第j个数的排名+1即比它小的偶数多了一个</span></span><br><span class="line">                    e[i].r=<span class="built_in">min</span>(o[j].r<span class="number">-1</span>,e[i].r);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//偶打于奇</span></span><br><span class="line">                &#123;</span><br><span class="line">                    e_rk[i]++;<span class="comment">//偶数组第i个数的排名+1即比它小的奇数多了一个</span></span><br><span class="line">                    e[i].l=<span class="built_in">max</span>(o[j].l+<span class="number">1</span>,e[i].l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//不相交通过比较区间范围可以得到大小关系，不需要询问</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e[i].l&gt;o[j].r) &#123;e_rk[i]++;s[j]=<span class="string">&#x27;&gt;&#x27;</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;o_rk[j]++;s[j]=<span class="string">&#x27;&lt;&#x27;</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;j++)<span class="comment">//每轮下来偶数组第i个数可以确定，此时再结合与该数的大小关系对奇数组每个数的取值范围进行进一步更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                o[j].l=<span class="built_in">max</span>(o[j].l,e_rk[i]*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                o[j].r=<span class="built_in">min</span>(o[j].r,e_rk[i]*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;! &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e_rk[i]*<span class="number">2</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;o_rk[i]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==(n+<span class="number">1</span>)/<span class="number">2</span>) cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="AK之神庇佑"><a href="#AK之神庇佑" class="headerlink" title="AK之神庇佑"></a>AK之神庇佑</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//            /\       |  /  |**、</span></span><br><span class="line"><span class="comment">//           /  \      | /   |   \</span></span><br><span class="line"><span class="comment">//          /    \     |/    |   /  _____                      ____   |  /</span></span><br><span class="line"><span class="comment">//         /------\    |\    |__/  /     \  \      /\      /  /    \  | /</span></span><br><span class="line"><span class="comment">//        /        \   | \   |    /       \  \    /  \    /  /______\ |/</span></span><br><span class="line"><span class="comment">//       /          \  |  \  |    \       /   \  /    \  /   \        |</span></span><br><span class="line"><span class="comment">//      /            \ |   \ |     \_____/     \/      \/     \_____  |</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *　　　　　　　　┏┓　　 　┏┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃ 　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　━　　 　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　＞　　　＜　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃...　⌒　... 　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┃　　　　　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　┗━┓　　　┏━┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃  　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　┗━━━┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　　　　　┣┓</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┃　　　　　　　┏┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　　┃┫┫　┃┫┫</span></span><br><span class="line"><span class="comment"> * 　　　　　　　　　　┗┻┛　┗┻┛</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// warm heart, wagging tail,and a smile just for you!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                            _ooOoo_</span></span><br><span class="line"><span class="comment">//                           o8888888o</span></span><br><span class="line"><span class="comment">//                           88&quot; . &quot;88</span></span><br><span class="line"><span class="comment">//                           (| -_- |)</span></span><br><span class="line"><span class="comment">//                           O\  =  /O</span></span><br><span class="line"><span class="comment">//                        ____/`---&#x27;\____</span></span><br><span class="line"><span class="comment">//                      .&#x27;  \|     |//  `.</span></span><br><span class="line"><span class="comment">//                     /  \|||  :  |||//  \</span></span><br><span class="line"><span class="comment">//                    /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">//                    |   | \\  -  /// |   |</span></span><br><span class="line"><span class="comment">//                    | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |</span></span><br><span class="line"><span class="comment">//                    \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">//                  ___`. .&#x27;  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">//               .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.</span></span><br><span class="line"><span class="comment">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">//         ======`-.____`-.___\_____/___.-`____.-&#x27;======</span></span><br><span class="line"><span class="comment">//                            `=---=&#x27;</span></span><br><span class="line"><span class="comment">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                                                                                                `</span></span><br><span class="line"><span class="comment">                                                                         `!!!;&#x27;                                                                 `</span></span><br><span class="line"><span class="comment">                                                           &#x27;%$@########################&amp;&amp;%:.                                                    `</span></span><br><span class="line"><span class="comment">                                                       .%###################################%.                                                  `</span></span><br><span class="line"><span class="comment">                                                    .`|######################################%                                                  `</span></span><br><span class="line"><span class="comment">                                                 .!@###############################################$&#x27;                                           `</span></span><br><span class="line"><span class="comment">                                              .!@#########################@@@#########################&amp;;.                                       `</span></span><br><span class="line"><span class="comment">                                             :@##################@@@&amp;&amp;@@@$!!%&amp;@@@@@@@###################&amp;&#x27;                                      `</span></span><br><span class="line"><span class="comment">                                          :&amp;################@@@&amp;$%%||||!!:&#x27;&#x27;:;!!||%|!%&amp;@@#################%`                                    `</span></span><br><span class="line"><span class="comment">                                         |###############@@&amp;&amp;$%|!;;::::&#x27;:&#x27;&#x27;&#x27;&#x27;:::;;!!|%%%$&amp;&amp;@###############$`                                   `</span></span><br><span class="line"><span class="comment">                                      :&amp;#############@&amp;$%||||!;&#x27;````````````&#x27;&#x27;&#x27;```&#x27;&#x27;:::&#x27;&#x27;:!|$@@###############;                                 `</span></span><br><span class="line"><span class="comment">                                    :@#############@$$%|!;;;;:&#x27;``````...```...`...`&#x27;&#x27;:::&#x27;&#x27;&#x27;;|%$$$&amp;############&amp;&#x27;                                `</span></span><br><span class="line"><span class="comment">                                   |##############&amp;$$$%||!!;:&#x27;`````..````....`...```&#x27;&#x27;::::;!!||$&amp;&amp;@@###########&amp;&#x27;                               `</span></span><br><span class="line"><span class="comment">                                 !##############@$%|!!!;::&#x27;&#x27;&#x27;`````...``.....`````````&#x27;&#x27;&#x27;::::;;::!|%$&amp;############|                              `</span></span><br><span class="line"><span class="comment">                                :@##########@&amp;%!:&#x27;`::;;:&#x27;``....```.......  .``....````````````&#x27;&#x27;:;!|%$@############;                            `</span></span><br><span class="line"><span class="comment">                               ;##########@%;```...`&#x27;&#x27;&#x27;`...  .....    ................   .`.    `:!!!!%%%&amp;#########|                            `</span></span><br><span class="line"><span class="comment">                              ;##########&amp;|:.`&#x27;`. ..`...   .......   .....  ..  .....   ...   .&#x27;&#x27;:!!:.`&#x27;&#x27;!@#########|.                          `</span></span><br><span class="line"><span class="comment">                              !##########|&#x27;`.;!`       .  ......          ..    .      ....  .::&#x27;`. .. .`&#x27;|@########@:                          `</span></span><br><span class="line"><span class="comment">                              ;##########%&#x27;`&#x27;%!    ..       .  .                ..    .```.   &#x27;;:`..``.`&#x27;:|@########@:                          `</span></span><br><span class="line"><span class="comment">                              !##########$:;$&amp;;                     . `|%;.  `;||;::`.``&#x27;;;.  .;!: `;:`&#x27;;|$#########@!.                         `</span></span><br><span class="line"><span class="comment">                              !##########@$&amp;@|. ...... .`&#x27;:!|;` !$|%%&#x27;!##$&#x27; `|####$:`:;:!&amp;$:. &#x27;$&amp;!&#x27;;!!||%&amp;############;                         `</span></span><br><span class="line"><span class="comment">                             `$#############&amp;:  `!!&#x27;`:;;;||%@&amp;!&#x27;!&amp;&amp;$;.|##%`.|#####%`&#x27;$@$&amp;##%` .:||;;;;%@##############!                         `</span></span><br><span class="line"><span class="comment">                             :@#############|. .!&amp;@|;%@@@@@&amp;@@#@&amp;@#@&amp;@############@@#####@:   .`&#x27;%@%!!&amp;###############!                         `</span></span><br><span class="line"><span class="comment">                             :@############@;   :&amp;@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `</span></span><br><span class="line"><span class="comment">                             :@############@:   `$#$%#@@##&amp;@################@$$$&amp;$%|!&#x27;       `%#@|;&#x27;:|&amp;###############!                         `</span></span><br><span class="line"><span class="comment">                              !##########@$%:    |####@&amp;######$;.                          ..`&#x27;`      ;@##############!                         `</span></span><br><span class="line"><span class="comment">                              !##########!       ;#########|.                             `;`         ;###############!                         `</span></span><br><span class="line"><span class="comment">                              ;##########;       `%######;                           &#x27;$###&amp;:          `%@############&amp;&#x27;                         `</span></span><br><span class="line"><span class="comment">                               !########@:       .&#x27;.       .:;`                   .|%:                   !##########&amp;&#x27;                          `</span></span><br><span class="line"><span class="comment">                               !########@:                                                               ;#########@:                           `</span></span><br><span class="line"><span class="comment">                                !######%.     !##&amp;;.        .                  `%&amp;!`             &#x27;&amp;###&amp;&#x27; !#########!                            `</span></span><br><span class="line"><span class="comment">                                |#######;.%###!                 `!&amp;###@|;;%@###%.    &#x27;;;|&amp;$:;;`     |#%. .%###%$###!                            `</span></span><br><span class="line"><span class="comment">                               !#######|  `%#&amp;&#x27;    |##&amp;$####&amp;:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `</span></span><br><span class="line"><span class="comment">                                !#$!$##!   :@#!        .|###$&#x27;.    ;##|.  :&amp;#@;    .``::`          ;@|.   :@#@: `$#|                            `</span></span><br><span class="line"><span class="comment">                                :&amp;&amp;|&amp;##;   :&amp;#!                   :&amp;##;    .%##!                   !&amp;&#x27;    ;@##!  |#!                            `</span></span><br><span class="line"><span class="comment">                                 |@@##@;  .`%#!                  &#x27;$##;      ;##$`                 :@!    .|##@; :&amp;!                             `</span></span><br><span class="line"><span class="comment">                                 !&amp;|&amp;##%:&#x27;.  :&amp;!                :@#%.        .%##;               |&amp;!.   `|@!   `$!                              `</span></span><br><span class="line"><span class="comment">                                 &#x27;$%%###&amp;;.   &#x27;&amp;&amp;&#x27;            `%##&amp;&#x27;           |##@&amp;:    ...;&amp;&amp;&amp;@;     .;&amp;#|&#x27;:;$&amp;:                              `</span></span><br><span class="line"><span class="comment">                                 .|######&amp;;        &#x27;$@@@@@@@@#|                                        :&amp;######%`                               `</span></span><br><span class="line"><span class="comment">                                   !#####&amp;:                                                           &#x27;$#####@:                                 `</span></span><br><span class="line"><span class="comment">                                   &#x27;$#####@:                                                          ;#####$`                                  `</span></span><br><span class="line"><span class="comment">                                     &#x27;&amp;####%.                 ``                                     &#x27;$#####;                                   `</span></span><br><span class="line"><span class="comment">                                      !#####$&#x27;                |@:  .:%|;;;;!$#####@#|               &#x27;&amp;###$:                                     `</span></span><br><span class="line"><span class="comment">                                       :&amp;####&amp;:               ;####################@:    &#x27;:`       `%###@:                                      `</span></span><br><span class="line"><span class="comment">                                         ;#####@%:.                                         `&#x27;&#x27;;|@######$`                                      `</span></span><br><span class="line"><span class="comment">                                         `$######@|`                                        !#&amp;||@#####$`                                       `</span></span><br><span class="line"><span class="comment">                                          :&amp;######@%&#x27;.                        .`&#x27;&#x27;&#x27;&#x27;` .&#x27;;!|%@#@$$@####&amp;:                                        `</span></span><br><span class="line"><span class="comment">                                           |######@|&#x27;.   ;##$!!%@##########################@:   &#x27;$####;                                         `</span></span><br><span class="line"><span class="comment">                                           :&amp;#####$;&#x27;&#x27;.`%#########&amp;&#x27;             `|@$:         .%###@;                                          `</span></span><br><span class="line"><span class="comment">                                            :@####@;          |#@##&amp;$;         `|%&#x27;           .|####!                                           `</span></span><br><span class="line"><span class="comment">                                              !####@;                                .        |####!                                            `</span></span><br><span class="line"><span class="comment">                                               :@###@|`         .                 `|!.       |####%.                                            `</span></span><br><span class="line"><span class="comment">                                                .|####!          `;$@%|!!!!!%&amp;&amp;@#$;.        !#####|                                             `</span></span><br><span class="line"><span class="comment">                                                .%####&amp;:              &#x27;%&amp;@@@|`             &#x27;&amp;#####|                                             `</span></span><br><span class="line"><span class="comment">                                                .%#####|.                                 :&amp;######%`                                            `</span></span><br><span class="line"><span class="comment">                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `</span></span><br><span class="line"><span class="comment">                                   `$#############&amp;%!%#####|.                         :@####%:..&#x27;!&amp;######@;                                     `</span></span><br><span class="line"><span class="comment">                                  `$#############|`..&#x27;%#######!                      ;####&amp;;.    .&#x27;%#######!                                    `</span></span><br><span class="line"><span class="comment">                                .|##############@!`    .&#x27;%#########%&#x27;.          &#x27;%#####%`           :@#######@%;:.                              `</span></span><br><span class="line"><span class="comment">                          ;%|;. !############%::;&#x27;        `!&amp;############@&amp;&amp;@#######@%&#x27;               !###########&amp;&#x27;                            `</span></span><br><span class="line"><span class="comment">                         !################$&#x27;   .:&#x27;         &#x27;|&amp;######################$:.               :@#############@@@@@@;                    `</span></span><br><span class="line"><span class="comment">                      &#x27;;$##&amp;;:&amp;###########$`                  :|$@################%:.                 !#####################@;                  `</span></span><br><span class="line"><span class="comment">                   &#x27;%####@$!:.  `%#########!                    .:!%&amp;@#######@%!;&#x27;.                   |##############%!$@####!                  `</span></span><br><span class="line"><span class="comment">                .|#######&amp;;&#x27;. .    |#######%.                      .&#x27;:;!!!!!!;`...                   .|############|. :$@@####%.                `</span></span><br><span class="line"><span class="comment">                !####&amp;$&amp;@#@!:&#x27;.       ;#####%`                  .`&#x27;;;&#x27;... ..&#x27;&#x27;``.                    !##########%`    &#x27;&#x27;&#x27;:$######$`             `</span></span><br><span class="line"><span class="comment">                ;#####@$$;`%&amp;:.         `%####;                   .:;;:&#x27;&#x27;:;||!:`                    !#########!          :&amp;#@@####!             `</span></span><br><span class="line"><span class="comment">          &#x27;%######@######!   !!            :$@$`                    ...`.&#x27;::`..                   &#x27;$######@!`         &#x27;|$$&amp;!!@#######@!.        `</span></span><br><span class="line"><span class="comment">     &#x27;$#########@&amp;$$@######@:    ;: . `&#x27;    ....                      ...``.                    `$######&amp;&#x27;           &#x27;!;`&#x27;!@######&amp;&amp;########$&#x27;  `</span></span><br><span class="line"><span class="comment">  ;############@#@@@@@$|%@###$`  `!!.;&#x27; .     :!.                                             .%#####!.            .;::&amp;####|`..`  ..;@########!&#x27;</span></span><br><span class="line"><span class="comment">  |########&amp;|;&#x27;``..`:&#x27;    ..!##%:.    ;;      `.                                            .|###|`             `&#x27;|###@&amp;$|`  ..   .`|&amp;&amp;@#######%:</span></span><br><span class="line"><span class="comment">  |###@#@@#&amp;|:`.`&#x27;;;:;!!!;:;&#x27;&#x27;!$##&amp;;&#x27;.  .&#x27;%; .;&amp;###&amp;|$!                                     &#x27;$; .|$:;|`   ...;&amp;###$&#x27;    ....      :||%&amp;########%:</span></span><br><span class="line"><span class="comment">  |#######@$;!%%:```           .!@###&amp;|`   :|&#x27;!########@#!                                ;@! :@####%&#x27;. `|@###&amp;:         ..`:::%$$&amp;$$$&amp;@##@@@##|:</span></span><br><span class="line"><span class="comment">  |########$;::&#x27;`         .`.     `%#####%!: .. !#####%` !#%.                        !; &#x27;%; !#############&amp;:          `::`.```. .&#x27;:.  :$@&amp;&amp;&amp;###|:</span></span><br><span class="line"><span class="comment">  !####@%:::;;:::::` .........            &#x27;.  !#######%;;&#x27;;; `%#&amp;&#x27;             ;&amp;: `;``$@!%########&amp;&amp;##&amp;|::::&#x27;.             &#x27;:.     `!%@@######|:</span></span><br><span class="line"><span class="comment">  !#####%;;::.       ...... ....`..  ..  &#x27;::!|&amp;########$&#x27;;%`.&#x27;` .;%:        !#$&#x27;;$%|&amp;$!&amp;##########$&#x27;        `&#x27;;;;;!&amp;##&amp;%||||||%;`   .:|&amp;###@###|:</span></span><br><span class="line"><span class="comment">  |#######|`...      `|$&amp;&amp;$$!`....           ;$:  :&amp;#@:     `&#x27;&#x27;&#x27;``.   .%########&amp;&#x27;  .%#@&amp;$%$#####$`     ....`:%&amp;@@@@@@&amp;&amp;@@!`.      .`&#x27;%@#######|&#x27;</span></span><br><span class="line"><span class="comment">  |######@@$:       .`..`!@&amp;$&amp;&amp;&amp;&amp;:                ;@#######@@#$%@######&amp;$;    &#x27;%@##%!@###@&amp;&amp;@####%.     `!&amp;@@@@@$:..`..``.``...     `|&amp;####@@##!&#x27;</span></span><br><span class="line"><span class="comment">  ;###&amp;|;::!&amp;#&amp;%%%%:         .&#x27;::::;|$&amp;&amp;$%|&#x27;..;%%&amp;#######%;$########@&amp;#####%`   &#x27;|@###;    &#x27;%####$;::::::`            &#x27;!|%%%%%%%%%&amp;#$:&#x27;::.&#x27;%###|&#x27;</span></span><br><span class="line"><span class="comment">  `%###@|;|%$%$@#&amp;|;::::`          &#x27;|%%%%%$%|%|;&#x27;;$##@|&#x27;.   |######&amp;&#x27;     .:|$%: :&amp;@|&#x27;.     !####%.              `::;:!$@######&amp;%%%%%!&#x27;  &#x27;:;&amp;##|:</span></span><br><span class="line"><span class="comment">  &#x27;$##%:.    :&amp;##@####@$;.  ..                    `$|     :; !#####|      &#x27;|%:  ``    ...   !####!          .  ..:&amp;#@@@@##@&amp;||$;         :&amp;####|&#x27;</span></span><br><span class="line"><span class="comment">  !####&amp;@@&amp;;        ...`.&#x27;%@##@@#@@&amp;!`            :&amp;&amp;!.       !###&amp;&#x27;  :||:.`   !%&#x27;     ``:$######@@@&amp;&amp;@@@&amp;@##$;``....             |@@@@########!&#x27;</span></span><br><span class="line"><span class="comment">  !#######@$||!:          &#x27;;!;;;!&amp;###&amp;|||||||||||%&amp;##@!`.     !###&amp;||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         &#x27;||||||&amp;#####%!;;$##!`</span></span><br><span class="line"><span class="comment">  `%#&amp;:.`:!||||||%@#@%;::;;;&#x27;                     ;@@:    .. .%###|.   `:::&#x27;  .:!;&#x27;`&#x27;:&#x27;`   `$####!             &#x27;:;;;;!%@@&amp;%%%|;`        `;%&amp;###|:</span></span><br><span class="line"><span class="comment">  .%##|..       &#x27;$##@@@@@@#&amp;:...`..              `$#$&#x27;        !##%`   ..`.`:%@@! &#x27;%@$:&#x27;&#x27;. .`|####|... .........`:%###@#@@@|`        ....`%#####|:</span></span><br><span class="line"><span class="comment">  !###@&amp;!       .`.```&#x27;:!&amp;##@&amp;&amp;&amp;&amp;$:              &#x27;&amp;#%.        !#&amp;&#x27;     ````.    .```:%&amp;&amp;&amp;&amp;&amp;@#####@!&#x27;:|$&amp;&amp;$&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@##|`````.       !@@@#######!&#x27;</span></span><br><span class="line"><span class="comment">  :&amp;#########@$||||:            `::::;;;;;!!;;;:;$###$&#x27;  .&#x27;`  |#@|.  .:;;:.                `%####%:&#x27;&#x27;&#x27;:::::`               `!||&amp;##$;;;:::.  ;##|:</span></span><br><span class="line"><span class="comment">  .%#@$%$%%%%%$@###$::::::&#x27;.           ...`;|!::!&amp;##@$%|||!&#x27; .%##&amp;%%$%&#x27;        `&#x27;.         :&amp;####!                  .&#x27;:::&#x27;::%@&amp;$%%!` .!!&#x27;:;$###%:</span></span><br><span class="line"><span class="comment">  :&amp;#############@|.              .  &#x27;$##################&amp;;..!@###@#######%&#x27;.             .!#####!          .              `$#####@|``;&amp;|!&amp;####|:</span></span><br><span class="line"><span class="comment">  |####&amp;%&#x27;   .&#x27;&#x27;&#x27;&#x27;&#x27;:|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&amp;$$$$$$&amp;######$:..:|%$$$$$$$&amp;&amp;&amp;&amp;@######&amp;;&#x27;&#x27;&#x27;.    ;$&amp;########|:</span></span><br><span class="line"><span class="comment">  |#######@%;;`    &#x27;!|!||$#######&amp;|!!!;;;!!!;`.!#####@: .;|!!|&amp;#$&#x27;   `:&#x27;&#x27;:;;$######################################%!|!!!!!;.  .`;|&amp;######@####%:</span></span><br><span class="line"><span class="comment">  |############$!&#x27;&#x27;&#x27;&#x27;..&#x27;;$&amp;&amp;&amp;&amp;@########################$;&#x27;!;`:@#&amp;:``&#x27;|$@######@@@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;@#######@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@&amp;&amp;&amp;&amp;$|:.    .`&#x27;&#x27;$########@&amp;@####%:</span></span><br><span class="line"><span class="comment">  |###&amp;%$&amp;#################@%;&#x27;  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&amp;##########%:</span></span><br><span class="line"><span class="comment">  |#######################################@&amp;&amp;@######################@@&amp;@#######################################################################%:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/09/07/markdown/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h2><p><a href="https://www.jianshu.com/p/25f0139637b7">公式编辑</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/09/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“<< DP >>”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="浮点数类型的DP"><a href="#浮点数类型的DP" class="headerlink" title="浮点数类型的DP"></a>浮点数类型的DP</h2><ul>
<li>题目来源：<a href="https://www.lanqiao.cn/problems/1032/learning/">画廊</a></li>
<li>思路：dp[i][j][k] 其中表示当前左边从下往上整理到了第i幅画，j表示当前右边当前整理到了第j幅画，k表示人当前在左边还是右边，0表示左边，1表示右边，这时只能人的位置只能在左边整理的最靠后的画的位置，右边也是同理，具体自己可以仔细想想，知道这点之后状态就很好转移了，dp[i] [j] [k]表示整理了左边前i幅画和右边前j幅画后人在左/右时需要走的最小距离。</li>
<li>初始化：<br>dp[1] [0] [0]为起点到左边第一幅画的距离；<br>dp[0] [1] [1]为起点到右边第一幅画的距离；<br>dp[i] [0] [0] = dp[i-1] [0] [0] + 左边i-1到i的距离；<br>dp[0] [j] [1] = dp[0] [j-1] [1] + 右边j-1到j的距离；</li>
<li>递推：<br>中间的每一步只会来自同一边的上一副画和对边的某幅画即：<br>dp[i] [j] [0] = min(dp[i-1] [j] [0]+左边i-1到i的距离 , dp[i-1] [j] [1]+右边j到左边i的距离);<br>dp[i][j][1] = min(dp[i][j-1][1]+右边j-1到j的距离 , dp[i][j-1][0]+左边i到右边j的距离);</li>
<li>结论：<br>最终结果=min（dp[L] [R] [0]+左边最后一副画到终点的距离，dp[L] [R] [1]+右边最后一副画到终点的距离）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x,y,z) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;<span class="meta-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="meta-string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//#x直接输出传入的变量名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">1e16</span>+<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">550</span>][<span class="number">550</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> l[<span class="number">550</span>],r[<span class="number">550</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(a*a+b*b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;INF&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;sqrt(5)&lt;&lt;sqrt(2)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">double</span> d,w;</span><br><span class="line">	cin&gt;&gt;L&gt;&gt;R&gt;&gt;d&gt;&gt;w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;i++) cin&gt;&gt;l[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++) cin&gt;&gt;r[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=L;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=R;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j][k]=INF;</span><br><span class="line">				<span class="comment">// cout&lt;&lt;dp[i][j][k]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">dis</span>(w/<span class="number">2.0</span>,l[<span class="number">1</span>]);</span><br><span class="line"> 	dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">dis</span>(w/<span class="number">2.0</span>,r[<span class="number">1</span>]);</span><br><span class="line"> 	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"> 	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=L;i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+l[i]-l[i<span class="number">-1</span>];</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=R;i++) dp[<span class="number">0</span>][i][<span class="number">1</span>]=dp[<span class="number">0</span>][i<span class="number">-1</span>][<span class="number">1</span>]+r[i]-r[i<span class="number">-1</span>];</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=R;j++)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			dp[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+l[i]-l[i<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+<span class="built_in">dis</span>(<span class="built_in">abs</span>(l[i]-r[j]),w));</span><br><span class="line"> 			dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">dis</span>(<span class="built_in">abs</span>(l[i]-r[j]),w),dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+r[j]-r[j<span class="number">-1</span>]);</span><br><span class="line"> 			<span class="comment">// if(i==3&amp;&amp;j==2) cout&lt;&lt;&quot;dis: &quot;&lt;&lt;dis(abs(l[i]-r[j]),w)&lt;&lt;&quot;  &quot;&lt;&lt;dp[i][j-1][0]&lt;&lt;endl;</span></span><br><span class="line"> 			<span class="comment">// if(i==3&amp;&amp;j==2) cout&lt;&lt;dp[i][j-1][1]&lt;&lt;&quot; &quot;&lt;&lt;r[i]-r[i-1]&lt;&lt;endl;</span></span><br><span class="line"> 			<span class="comment">// debug(i,j,dp[i][j][0]);</span></span><br><span class="line"> 			<span class="comment">// debug(i,j,dp[i][j][1]);</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">   <span class="keyword">double</span> ans=<span class="built_in">min</span>(dp[L][R][<span class="number">0</span>]+<span class="built_in">dis</span>(d-l[L],w/<span class="number">2</span>),dp[L][R][<span class="number">1</span>]+<span class="built_in">dis</span>(d-r[R],w/<span class="number">2</span>));<span class="comment">//保留两位小数，round只保留到整数所以要先乘以一百</span></span><br><span class="line">   ans=<span class="built_in">round</span>(ans*<span class="number">100</span>)/<span class="number">100</span>;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2 100 10</span></span><br><span class="line"><span class="comment">4 10 71</span></span><br><span class="line"><span class="comment">32 96</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="括号匹配问题（卡特兰数）"><a href="#括号匹配问题（卡特兰数）" class="headerlink" title="括号匹配问题（卡特兰数）"></a>括号匹配问题（卡特兰数）</h2><p>n对括号正确匹配数目<br>给定n对括号，求括号正确配对的字符串数，例如：<br>0对括号：[空序列] 1种可能<br>1对括号：() 1种可能<br>2对括号：()() (()) 2种可能<br>3对括号：((())) ()(()) ()()() (())() (()()) 5种可能<br>那么问题来了，n对括号有多少种正确配对的可能呢。<br>考虑n对括号时的任意一种配对方案，最后一个右括号有唯一的与之匹配的左括号，于是有唯一的表示A(B)，其中A和B也是合法的括号匹配序列<br>假设S(n)为n对括号的正确配对数目，那么有递推关系S(n)=S(0)S(n-1)+S(1)S(n-2) +…+S(n-1)S(0)，显然S(n)是卡特兰数。</p>
<h2 id="给定节点组成二叉搜索树（卡特兰数）"><a href="#给定节点组成二叉搜索树（卡特兰数）" class="headerlink" title="给定节点组成二叉搜索树（卡特兰数）"></a>给定节点组成二叉搜索树（卡特兰数）</h2><p>给定N个节点，能构成多少种不同的二叉搜索树。<br>假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则<br>G(n) = f(1) + f(2) + f(3) + f(4) + … + f(n)</p>
<p>当 i 为根节点时，其左子树节点个数为 i-1 个（左子树的值比根节点小），右子树节点为 n-i（右子树的值比根节点大），则<br>f(i) = G(i-1)*G(n-i)</p>
<p>综合两个公式可以得到 卡特兰数 公式<br>G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<h2 id="最长公共上升子序列-LCIS"><a href="#最长公共上升子序列-LCIS" class="headerlink" title="最长公共上升子序列(LCIS)"></a>最长公共上升子序列(LCIS)</h2><ul>
<li>状态：f[i][j]表示a串前i个字符和b串前j个字符且以b[j]结尾的最长LCIS.</li>
</ul>
<ol>
<li>o(n^3)算法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], f[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> max1 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i] &gt; b[k]) max1 = <span class="built_in">max</span>(max1,f[i<span class="number">-1</span>][k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                f[i][j] = max1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>o(n^2)算法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3030</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], f[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="comment">//maxv维护的值是max(f[i-1][k]),1=&lt; k &lt;=j-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j],maxv);</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[j]) maxv = <span class="built_in">max</span>(maxv,f[i][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="dp-滚动数组对空间进行优化"><a href="#dp-滚动数组对空间进行优化" class="headerlink" title="dp+滚动数组对空间进行优化"></a>dp+滚动数组对空间进行优化</h2><ul>
<li>若在时间复杂度允许的情况下空间复杂度不允许，那么一定要考虑是否可以利用状态转移的关系来对空间进行压缩，比如：如果该状态只需要当前行以及前一行的状态来进行转移，那么可以将行的维度压缩至二维，这样大一大大减少空间。</li>
<li>压缩空间后可能需要考虑对每一次要转移的状态进行初始化，因为其中可能储存着前面状态的数据！<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">bool</span> grid[N][N];</span><br><span class="line">ll dp[<span class="number">2</span>][N][<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,q,p;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q+p&gt;n+m<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum+=grid[<span class="number">1</span>][i];</span><br><span class="line">		dp[<span class="number">1</span>][i][sum]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n+m-p<span class="number">-1</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp=<span class="number">0</span>;<span class="comment">//若不用中间变量应该初始化当前这一维的数据，本题应初始化为0</span></span><br><span class="line">				<span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(k<span class="number">-1</span>&gt;=<span class="number">0</span>) tmp=(tmp+dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(k<span class="number">-1</span>&gt;=<span class="number">0</span>) tmp=(tmp+dp[i%<span class="number">2</span>][j<span class="number">-1</span>][k<span class="number">-1</span>])%mod;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						tmp=(tmp+dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j][k])%mod;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						tmp=(tmp+dp[i%<span class="number">2</span>][j<span class="number">-1</span>][k])%mod;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i%<span class="number">2</span>][j][k]=tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=q;i&lt;=n+m<span class="number">-1</span>-p;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		ans=(ans+dp[n%<span class="number">2</span>][m][i])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2></li>
<li>背包容量应该从大到小枚举，避免小的背包取到该物品，大的背包也取到，导致重复。</li>
<li>比如：若背包容量从小到大枚举，对于第i个物品，其需要容量为k，对于某个容量为j（j&gt;k）的背包，可以取到该物品（取到后价值最大），而对于容量为j+k的背包，当它取到该物品后容量为j，即也取到背包容量为j中的物品，容量为j的背包如前文所说也取到了该物品，因此（j+k）背包取到重复物品，这样是不可取的，因此背包容量应从大到小枚举。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[t]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[t]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>n种物品有对应的价值，但也有相应的数目限制，求其能构成的价值在1 - m内有多少种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1010</span>],c[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(m||n))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i];<span class="comment">//n种硬币的价值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;c[i];<span class="comment">//n种硬币的数目</span></span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//记录某个价值是否能由硬币构成</span></span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举每种硬币，观察其能构成哪些价值</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">			<span class="comment">//从该种硬币能构成的最小价值v[i]枚举值范围上界m,观察是否能由该种硬币参与构成，并用cnt数组记录某个数用到该种硬币的数目，避免超出该硬币总数</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!dp[j]&amp;&amp;dp[j-v[i]]&amp;&amp;cnt[j-v[i]]&lt;c[i])<span class="comment">//j未出现过且j-v[i]出现过且j-v[i]用到的硬币数少于第i种硬币总数，那么j可以由第i种硬币参与构成</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//cout&lt;&lt;j&lt;&lt;&quot; &quot;;</span></span><br><span class="line">					cnt[j]=cnt[j-v[i]]+<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">					dp[j]=<span class="number">1</span>;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包变形（容量为i且刚好装满的背包）"><a href="#0-1背包变形（容量为i且刚好装满的背包）" class="headerlink" title="0 - 1背包变形（容量为i且刚好装满的背包）"></a>0 - 1背包变形（容量为i且刚好装满的背包）</h2><p>n个物品，给定一个k，每个物品有两个值$a_i,b_i$，问如何选择是选出的$a_i$的和与$b_i$的和的比值为k且此时$a_i$的和最大。<br>由公式可知，若选出的物品符合比值为k则应该有选出的所有物品的 $a_i-b_i<em>k$的和为0，结合0-1背包，将$a_i-b_i</em>k$视作每个物品的体积$v_i$，$a_i$ 为每个物品的价值。又因为求出的$v_i$有正有负以及0，因此需要对$v_i$分正负讨论而且不能忘记0。<br><a href="https://codeforces.com/problemset/problem/366/C">codeforces</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp1[N];<span class="comment">//dp1[i]表示选体积为正的物品且背包容量为i能得到的最大价值</span></span><br><span class="line"><span class="keyword">int</span> dp2[N];<span class="comment">//dp2[i]表示选体积为负的物品且背包容量为i能得到的最大价值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>],b[<span class="number">110</span>],c[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;b[i];</span><br><span class="line">		c[i]=a[i]-b[i]*k;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp1[i]=-INF;</span><br><span class="line">		dp2[i]=-INF;</span><br><span class="line">	&#125;</span><br><span class="line">	dp1[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	dp2[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化dp[0]为0，其他容量的背包的初始值为-INF，目的是求出最后的价值后若其值为正数，则表示该容量的背包刚好装满	</span></span><br><span class="line">	<span class="comment">//如若dp1[i]为正数则表示取出的正体积物品的体积之和刚好为i能得到的最大价值</span></span><br><span class="line">	<span class="comment">//如若dp2[i]为正数则表示取出的负体积物品的体积之和刚好为i能得到的最大价值</span></span><br><span class="line">	<span class="comment">//因此dp1[i]+dp2[i]的最大值即为答案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i]&gt;=<span class="number">0</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">100000</span>;j&gt;=c[i];j--)</span><br><span class="line">			&#123;</span><br><span class="line">				dp1[j]=<span class="built_in">max</span>(dp1[j],dp1[j-c[i]]+a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">100000</span>;j&gt;=-c[i];j--)</span><br><span class="line">			&#123;</span><br><span class="line">				dp2[j]=<span class="built_in">max</span>(dp2[j],dp2[j+c[i]]+a[i]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100000</span>;i++) ans=<span class="built_in">max</span>(ans,dp1[i]+dp2[i]);<span class="comment">//i一定从0开始</span></span><br><span class="line">	<span class="comment">//for(int i=1;i&lt;=10;i++) cout&lt;&lt;dp1[i]&lt;&lt;&quot; &quot;&lt;&lt;dp2[i]&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包变种"><a href="#0-1背包变种" class="headerlink" title="0-1背包变种"></a>0-1背包变种</h2><p>dp[i][j][h][k]表示对于前i个物品、已选价值为j、已有h个必选品且已有k个必不选品，故转移方程为：dp[i][j][h][k]=dp[i][j][h][k]+dp[i-1][j-a[i]][h][k]+dp[i-1][j-a[i]][h-1][k]+dp[i-1][j][h][k-1]+dp[i-1][j][h][k]。由于两种必选的位置可交换，两种必不选的位置也可交换，故最终结果应该乘4。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5800">HDU - 5800</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,n,m;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;=<span class="number">2</span>;h++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">					&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j-a[i]&gt;=<span class="number">0</span>) dp[i][j][h][k]=(dp[i][j][h][k]+dp[i<span class="number">-1</span>][j-a[i]][h][k])%mod;</span><br><span class="line">                        <span class="comment">//选第i个物品，但是第i个物品不作为必选品进行标记</span></span><br><span class="line">						<span class="keyword">if</span>(j-a[i]&gt;=<span class="number">0</span>&amp;&amp;h<span class="number">-1</span>&gt;=<span class="number">0</span>) dp[i][j][h][k]=(dp[i][j][h][k]+dp[i<span class="number">-1</span>][j-a[i]][h<span class="number">-1</span>][k])%mod;</span><br><span class="line">                        <span class="comment">//选第i个物品，但是第i个物品不作为必选品进行标记</span></span><br><span class="line">						<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;k<span class="number">-1</span>&gt;=<span class="number">0</span>) dp[i][j][h][k]=(dp[i][j][h][k]+dp[i<span class="number">-1</span>][j][h][k<span class="number">-1</span>])%mod;</span><br><span class="line">                        <span class="comment">//不选第i个物品，且第i个物品作为必不选品进行标记</span></span><br><span class="line">						<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) dp[i][j][h][k]=(dp[i][j][h][k]+dp[i<span class="number">-1</span>][j][h][k])%mod;</span><br><span class="line">						<span class="comment">//不选第i个物品，且第i个物品不作为必不选品进行标记</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans=(ans+dp[n][i][<span class="number">2</span>][<span class="number">2</span>])%mod;</span><br><span class="line">		ans=(ans*<span class="number">4</span>)%mod;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包变形-路径输出"><a href="#0-1-背包变形-路径输出" class="headerlink" title="0 - 1 背包变形+路径输出"></a>0 - 1 背包变形+路径输出</h2><ul>
<li>定义状态dp[i] [j]为对于前i个物品且时间为j的情形下拿到的最大物品价值</li>
<li>定义状态pre[i] [j]为对于前i个物品且时间为j的情形下是否拿了第i个物品（1 拿 0 不拿）</li>
<li>需要注意的是需要对物品的完全烧毁时间从小到大排序再进行顺序枚举，不按时间顺序排序会出错，因为若时间较小的在后面，那么拿了它之后不能再拿前面时间较大的物品，但有些情况是可以先拿前面时间较大的在用剩余的时间拿那个时间较小的物品。</li>
<li>路径输出时先找到哪个时间能够获得最大受益即dp[n][time]，若该状态的pre标记为1则表示选择了该物品，此时只需要看下一状态dp[n-1][time-t[i]],否则就看另一状态dp[n-1] [time]，将选择的物品标号记录下来即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">bool</span> pre[N][<span class="number">2010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.d==b.d) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> time,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pre[i][time])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i<span class="number">-1</span>,time-node[i].t,cnt+<span class="number">1</span>);</span><br><span class="line">		cout&lt;&lt;node[i].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i<span class="number">-1</span>,time,cnt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;node[i].t&gt;&gt;node[i].d&gt;&gt;node[i].w;</span><br><span class="line">		node[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2000</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=node[i].t&amp;&amp;j&lt;node[i].d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i][j]&lt;dp[i<span class="number">-1</span>][j-node[i].t]+node[i].w)</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][j-node[i].t]+node[i].w;</span><br><span class="line">					pre[i][j]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans&lt;dp[n][i]) </span><br><span class="line">		&#123;</span><br><span class="line">			time=i;</span><br><span class="line">			ans=dp[n][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;&quot;t:&quot;&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;pre[3][5]&lt;&lt;&quot; &quot;&lt;&lt;pre[2][2]&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">dfs</span>(n,time,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="本质上升子序列"><a href="#本质上升子序列" class="headerlink" title="本质上升子序列"></a>本质上升子序列</h2><ul>
<li><p>要求：给定一个字符串（任意）序列s，求出其中所有不同的上升子序列的个数。</p>
</li>
<li><p>思路：本来一开始想从最长上升子序列的思考方式入手看看能不能找到灵感，结果发现最长和所有还是差的有点远；但是自己又始终跳不出去去重这个概念，”不全部找出来怎么去重”这个概念在我脑海中迟迟消散不去，但是要是枚举出所有的情况在时间上肯定是行不通的，于是想到从贡献度方面着手，只要不将重复的子序列不计入贡献即可，于是想到了通过递推算出以妹子==每个字符结尾的本质上升子序列的贡献度最后相加即可。</p>
</li>
<li><p>定义状态：</p>
<p>dp[i]:表示以第i个字符结尾的本质上升子序列的个数</p>
</li>
<li><p>转移方程：</p>
<p>在状态转移的过程中需要处理重复个数的计算，很容易想到第i个字符在向前寻找符合要求（即该上升子序列的末尾比s[i]小）的上升子序列的过程中遇到相同的字符那么就没有必要再往前寻找了，前面的字符的贡献度已经被该相同字符计算过了，因此转移方程为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]&gt;s[j]) &#123; dp[i] + = dp[j]; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：需要注意单个字符作为上升子序列时的贡献度，如果前面有相同的字符那么就不需要再加1了， 否则加1.</p>
</li>
<li><p><a href="https://www.lanqiao.cn/problems/1021/learning/">本质上升序列</a></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000</span>];<span class="comment">//dp[i]表示以第i个字符结尾的不同上升子序列个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> i,j,ans=<span class="number">0</span>;</span><br><span class="line">	string s=<span class="string">&quot;tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">	s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j]==s[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]&gt;s[j])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i]+=dp[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;<span class="number">1</span>) dp[i]++;<span class="comment">//如果之前没有遇到和自己相同的字符，本身才能算一个</span></span><br><span class="line">		ans+=dp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列（O-N-logN-）"><a href="#最长上升子序列（O-N-logN-）" class="headerlink" title="最长上升子序列（O(N * logN)）"></a>最长上升子序列（O(N * logN)）</h2><p>a[i]表示第i个数据。<br>dp[i]表示表示长度为i+1的LIS结尾元素的最小值。<br><strong>利用贪心的思想，对于一个上升子序列，显然当前最后一个元素越小，越有利于添加新的元素，这样LIS长度自然更长。</strong><br>因此，我们只需要维护dp数组，其表示的就是长度为i+1的LIS结尾元素的最小值，保证每一位都是最小值<br><strong>这样子dp数组的长度就是LIS的长度。</strong><br>dp数组具体维护过程同样举例讲解更为清晰。<br>同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp的变化过程如下：</p>
<ul>
<li>dp[0] = a[0] = 1，长度为1的LIS结尾元素的最小值自然没得挑，就是第一个数。 （dp = {1}）</li>
<li>对于a[1]=7，a[1]&gt;dp[0]，因此直接添加到dp尾，dp[1]=a[1]。（dp = {1, 7}）</li>
<li>对于a[2]=3，dp[0]&lt; a[2]&lt; dp[1]，因此a[2]替换dp[1]，令dp[1]=a[2]，因为长度为2的LIS，结尾元素自然是3好过于7，因为越小这样有利于后续添加新元素。 （dp = {1, 3}）</li>
<li>对于a[3]=5，a[3]&gt;dp[1]，因此直接添加到dp尾，dp[2]=a[3]。 （dp = {1, 3, 5}）</li>
<li>对于a[4]=9，a[4]&gt;dp[2]，因此同样直接添加到dp尾，dp[3]=a[9]。 （dp = {1, 3, 5, 9}）</li>
<li>对于a[5]=4，dp[1]&lt; a[5]&lt; dp[2]，因此a[5]替换值为5的dp[2]，因此长度为3的LIS，结尾元素为4会比5好，越小越好嘛。（dp = {1, 3, 4, 9}）</li>
<li>对于a[6]=8，dp[2]&lt; a[6]&lt; dp[3]，同理a[6]替换值为9的dp[3]，道理你懂。 （dp = {1, 3, 5, 8}）</li>
</ul>
<p>这样子dp数组就维护完毕，所求LIS长度就是dp数组长度4。<br>通过上述求解，可以发现dp数组是单调递增的，因此对于每一个a[i]，先判断是否可以直接插入到dp数组尾部，</p>
<p>即比较其与dp数组的最大值即最后一位；如果不可以，则找出dp中第一个大于等于a[i]的位置，用a[i]替换之。<br>这个过程可以利用<strong>二分查找</strong>，因此查找时间复杂度为O(logN)，所以总的时间复杂度为O(N*logN)</p>
<p>例题：<a href="http://lx.lanqiao.cn/problem.page?gpid=T2874">游园安排</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">string s[<span class="number">1000005</span>], dp[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000005</span>], pos[<span class="number">1000005</span>], g[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)str.<span class="built_in">length</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">			n++;</span><br><span class="line">		s[n] += str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//最新的达到最长的子序列在s中的位置(记作k),len是最长长度 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="built_in">lower_bound</span>(dp+<span class="number">1</span>, dp+<span class="number">1</span>+len, s[i])-dp<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(p+<span class="number">1</span> &gt;= len)<span class="comment">//如果是最大的字符串，特殊处理边界</span></span><br><span class="line">			k = i, len = p+<span class="number">1</span>;</span><br><span class="line">		dp[p+<span class="number">1</span>] = s[i], pos[p+<span class="number">1</span>] = i;<span class="comment">//pos记录P+1位置上的字符串编号</span></span><br><span class="line">		f[i] = pos[p];<span class="comment">//记录该字符串的前一个字符串编号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = k; i; i = f[i])</span><br><span class="line">	&#123;</span><br><span class="line">		g[f[i]] = i;<span class="comment">//建立反向的链表关系，准备输出结果 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for(int i=0;i&lt;=n;i++) cout&lt;&lt;s[i]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">//字符串标号从1开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != k; i = g[i])</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;s[i]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">		cout &lt;&lt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s[k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///错误示范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt; dp;</span><br><span class="line">vector&lt;string&gt; str;</span><br><span class="line">map&lt;string,string&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;mp[&quot;asdad&quot;]&lt;&lt;endl;</span></span><br><span class="line">	string tmp,s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> it=s[i];</span><br><span class="line">		<span class="keyword">if</span>(it&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;it&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tmp!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			tmp=it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> tmp+=it;</span><br><span class="line">	&#125;</span><br><span class="line">	str.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string it=str[i];</span><br><span class="line">		<span class="comment">//		cout&lt;&lt;it&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">		vector&lt;string&gt;::iterator pos=<span class="built_in">upper_bound</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),it);</span><br><span class="line">		<span class="keyword">if</span>(pos==dp.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//			cout&lt;&lt;&quot;1\n&quot;;</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(dp.<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				mp[it]=<span class="string">&quot;ok&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//				cout&lt;&lt;&quot;pos-1&quot;&lt;&lt;*(pos-1)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">				mp[it]=*(pos<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			dp.<span class="built_in">insert</span>(pos,it);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//			cout&lt;&lt;&quot;2\n&quot;;</span></span><br><span class="line">			*pos=it;</span><br><span class="line">			<span class="keyword">if</span>(pos==dp.<span class="built_in">begin</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				mp[it]=<span class="string">&quot;ok&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				mp[it]=*(pos<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	tmp=dp.<span class="built_in">back</span>();</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;&quot;tmp: &quot;&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">while</span>(tmp!=<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//		cout&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">		ans=tmp+ans;</span><br><span class="line">		tmp=mp[tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WoAiLanQiaoBei</span></span><br></pre></td></tr></table></figure>

<h2 id="最长上升公共子序列（LCIS）"><a href="#最长上升公共子序列（LCIS）" class="headerlink" title="最长上升公共子序列（LCIS）"></a>最长上升公共子序列（LCIS）</h2><ul>
<li>核心思路：<ul>
<li>最长公共上升子序列的代码就是在最长公共子序列上找一遍最长上升子序列即可。也就是在判断a[i] = = b[j]的前提下，再求出上升序列</li>
<li>f[i][j]代表所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合；</li>
<li>f[i] [j]的值等于该集合的子序列中长度的最大值；</li>
<li>复杂度O(n3)</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; b[k])</span><br><span class="line">                    maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][k] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优化后的做法：第三层for循环是用来求之前的，小于a[i]的最长公共上升子序列+1长度，实际上我们需要知道的只有之前的最长公共上升子序列的长度，这样一来我们可以用一个变量val来存放 F[ i-1 ] [ k ] 中的最大值，从而就可以省略第三层循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给定一个字符串，求最少添加几个字符可以使其成为回文字符串。</p>
<ul>
<li>第一眼看到想到的是求出最长回文子串长度len，用总长度n减去该长度len，其实不然，因为这并不是最优解，因为字符插入的位置是任意的而不是只有两边可以插入！(如：abcfgcba只需加入一个字符，因为最长回文子序列为abcfcba，只需假如一个g即可，而求出的最长回文子串长度却是1，因此需要求的是最长回文子序列而非最长回文子串)</li>
<li>本题需要求的是最长回文子序列，而manacher算法可以求的是最长回文子串，这两点还是有很大区别的!</li>
<li>因此本题的做法是：将字符串反转求其最长公共子序列（lcs）即为最长回文子序列!</li>
<li>通常的做法需要二维数组来记录答案，当字符串长度较长时空间浪费较大，且容易被卡空间，因此需要进行状态压缩，因为只需要用到第i维和第i-1维的数据，因此数组只需要开dp[2] [N]即可。</li>
<li>注意：字符串倒转后只能求最长回文子序列，不能求最长回文子串（如aacakdbacaa）,其中aaca 和acaa倒转后是一样的会算作长度为4的回文子串。</li>
<li>最长回文子串可以o（n^2）的做法区间dp，dp[i] [j] =1表示si….j为回文子串</li>
<li>-<a href="http://poj.org/problem?id=1159">POJ - 1159</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	string s;</span><br><span class="line">	string ss;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		ss=s;</span><br><span class="line">		<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		ss=<span class="string">&quot; &quot;</span>+ss;</span><br><span class="line">		s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ss[i]==s[j])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;n-dp[n][n]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*滚动数组*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> dp[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	string s;</span><br><span class="line">	string ss;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		ss=s;</span><br><span class="line">		<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		ss=<span class="string">&quot; &quot;</span>+ss;</span><br><span class="line">		s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ss[i]==s[j])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i%<span class="number">2</span>][j]=dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[i%<span class="number">2</span>][j]=<span class="built_in">max</span>(dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j],dp[i%<span class="number">2</span>][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;n-dp[n%<span class="number">2</span>][n]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><ol>
<li>给定一个字符串s，可以在另一空串上进行如下操作：选中任一区段，可以将该区段上的所有字符变为同一字母，问最少需要操作多少次可以将该空串变为字符串s。</li>
</ol>
<ul>
<li>dp[i][j]表示由空串变为s中区间 i - j 上的子串最少需要多少步操作。（字符串标号从1开始）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len=b.<span class="built_in">length</span>();</span><br><span class="line">		b=<span class="string">&quot; &quot;</span>+b;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) dp[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(b[j]==b[i]) dp[i][j]=dp[i][j<span class="number">-1</span>];<span class="comment">//如果区间[i - j]上第一个字符和最后一个字符相同，那么有由空串变为该字符串的最少操作次数和区间[i - j-1]上一样</span></span><br><span class="line">				<span class="keyword">else</span><span class="comment">//否则枚举分隔点，将该区间分为两部分，取所有情形的最小值即可</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">								</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;dp[<span class="number">1</span>][len]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>现在题目变为由字符串a变为字符串s，那么最少的操作次数又为多少呢？<br>先初始串每个位置已经有了相应的字符，不同于初始串为空串的情形，因为如果两串相同位置上对应字符相同那么操作的次数可能会减少，比如” “ -&gt; “aabaa” 两次，”aacaa” -&gt; “aabaa” 只需一次操作。</li>
</ol>
<ul>
<li>先定义ans[i]表示将a串的[1 - i]区间变为s串的[1 - i]区间所需的最少操作次数，由上文求出的dp值，可给ans[i]进行初始化，即ans[i]=dp[1][i]，ans[i]的值最多也就是从空串转为s串的操作次数，因后续要求最小值，故先赋一个合理的最大值初值。<br><a href="https://acm.dingbacode.com/showproblem.php?pid=2476">HDU - 2476</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len=b.<span class="built_in">length</span>();</span><br><span class="line">		b=<span class="string">&quot; &quot;</span>+b;</span><br><span class="line">		a=<span class="string">&quot; &quot;</span>+a;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) dp[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(b[j]==b[i]) dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">								</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) ans[i]=dp[<span class="number">1</span>][i] ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[i]) ans[i]=ans[i<span class="number">-1</span>];<span class="comment">//如果a[i]==b[i]那么只有一种选择，即选择区间[1 - i-1] 和 [i - i],这样ans[i]=ans[i-1]+0,这种选择最优</span></span><br><span class="line">			<span class="keyword">else</span><span class="comment">//否则就枚举分隔点</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) ans[i]=<span class="built_in">min</span>(ans[i],ans[j]+dp[j+<span class="number">1</span>][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans[len]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="树形DP-换根"><a href="#树形DP-换根" class="headerlink" title="树形DP+换根"></a>树形DP+换根</h2><p>给出一棵带权值，权值表示节点间的最大流量，A(x)表示x结点流向各叶子结点的最大流量，求A(x)的最大值。</p>
<ul>
<li>容易想到每次枚举一个根节点，设立状态f[x]表示以该节点为根的子树能够流出的最大流量，那么状态转移方程为$A(x)=\sum_{y邻接x}min(A(y),e(x,y))$,然后利用树形dp即可暴力求得最大值。</li>
<li>但是由于父节点与儿子结点的特殊关系，可以对二者进行换根，由此可以利用之前计算的结果来更快的算出每个A(x)。</li>
<li>我们发现换根后，x的流量就没有了y的部分，其他都还在，此时x的流量就是原本的减去从y流向x的部分，new[x]=flow[ x ] - min ( flow[ y ] , edge[ x ] [ y ] ),这个new表示x新的流量<br>我们再看y，y的流量多了从x流来的部分，y的流量就是flow[y]+min(new[x],edge[x][y])，因为换根x的流量发生改变。直接上图，帮助理解<img src="/images/loading.png" data-original="/2021/09/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8D%A2%E6%A0%B9.png" alt="换根图"></li>
<li>d[y]表示以1号结点为根时以y节点为根的子树能够流出的最大流量,也就是上图中的flow[y]。</li>
<li>注意根节点只有一颗子树的情形和孩子结点为叶子的情形，这两种情况进行换根时计算方式与一般情形有所区别。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> edge[<span class="number">2</span>*N],to[<span class="number">2</span>*N],head[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],deg[N],d[N],dp[N];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ne[++tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	to[tot]=v;</span><br><span class="line">	edge[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span><span class="comment">//假设以一号节点为根的情形，以便后续换根的计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(deg[v]==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=edge[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,root);</span><br><span class="line">			ans+=<span class="built_in">min</span>(d[v],edge[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d[root]=ans;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(deg[root]==<span class="number">1</span>)<span class="comment">//根节点只有一颗子树的情形</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[v]=d[v]+edge[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(deg[v]==<span class="number">1</span>)<span class="comment">//儿子结点为叶子结点的情形</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[v]=d[v]+<span class="built_in">min</span>(dp[root]-edge[i],edge[i]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//一般情形</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[v]=d[v]+<span class="built_in">min</span>(dp[root]-<span class="built_in">min</span>(edge[i],d[v]),edge[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>(v,root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n,u,v,w;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="comment">// scanf(&quot;%d&quot;,&amp;t);</span></span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">		<span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(deg));</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			<span class="comment">// scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span></span><br><span class="line">			<span class="built_in">add</span>(u,v,w);</span><br><span class="line">			<span class="built_in">add</span>(v,u,w);</span><br><span class="line">			deg[u]++;</span><br><span class="line">			deg[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		dp[<span class="number">1</span>]=d[<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">max</span>(dp[i],ans);</span><br><span class="line">			<span class="comment">//cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="comment">// printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><h2 id="P4796路径"><a href="#P4796路径" class="headerlink" title="P4796路径"></a>P4796路径</h2><ul>
<li>题目来源：<a href="https://www.luogu.com.cn/problem/P4796">P4796-路径</a></li>
<li>题意：给定一张 N 个点 M 条边的无向图，每个点有一个颜色，所有点的颜色共有 KK 种，编号为 1…K。求图上有多少条长度至少为 2 的简单路径，满足路径上的每一个点的颜色互不相同（经过两个点即为长度为2）。</li>
<li>思路：一看到题目容易想到存储到达前一个的状态在枚举下一个可能到达的状态进行搜索，那么便需要存储前面所经过的所有颜色，而颜色总数最多仅有5种，于是可以用二进制来表示是否经过该种颜色（0未经过，1经过），那么对于k种颜色来说共有1 &lt;&lt; k种状态，于是可以状压dp求出总方案数。</li>
<li>dp[i][j]表示当前到达的点为i且经过的颜色用j的二进制表示（如k=5时，j可以为10001，也就是说经过了第一种和第五种颜色）</li>
<li>状态转移方程：dp[k][j+1&lt;&lt;(color[k]-1)]+=dp[i]<a href="k%E4%B8%BAi%E7%9A%84%E9%82%BB%E6%8E%A5%E7%82%B9%EF%BC%8C%E4%B8%94%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3k%E7%82%B9%E7%9A%84%E9%A2%9C%E8%89%B2color%5Bk%5D%E6%AD%A4%E6%97%B6%E5%9C%A8i%E7%82%B9%E5%B9%B6%E6%B2%A1%E6%9C%89%E7%BB%8F%E8%BF%87%EF%BC%88if((j%3E%3E(color%5Bk%5D-1)&1)">j</a> continue;）)</li>
<li>注意：枚举经过颜色的状态j时必须从颜色数目较小网较大的进行枚举，也就是j中1的个数较少的先枚举，否则会遗漏某些状态。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; adj[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; all_sta;</span><br><span class="line">ll dp[N][<span class="number">1</span>&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __builtin_popcount(a)&lt;__builtin_popcount(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n,m,k,u,v;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;color[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tot;i++) all_sta.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">sort</span>(all_sta.<span class="built_in">begin</span>(),all_sta.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">1</span>&lt;&lt;(color[i]<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i:all_sta)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[j][i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(__builtin_popcount(i)&gt;=<span class="number">2</span>) ans+=dp[j][i];</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">auto</span> it:adj[j])</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>((i&gt;&gt;(color[it]<span class="number">-1</span>)&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">						dp[it][i+(<span class="number">1</span>&lt;&lt;(color[it]<span class="number">-1</span>))]+=dp[j][i];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a>炮兵阵地</h2><p>给出一幅包含平原（P）、高地（H） 的地图，只有平原上可以放置炮兵，且放置的炮兵不能伤到自己人，也就是上下左右两个位置内不能有其余的炮兵，求最多可放置的炮兵数。</p>
<ul>
<li>状态压缩首先可以根据题目给定的条件枚举出所有合理的状态，比如本题中，每一行的状态中炮兵每个位置两个位置范围内不能有其余炮兵（假设炮兵为1），那么不能出现11或101或111的情形，那么合理的状态为1001之类，那么判断的不合理状态按位与上它左移一位或两位的数会有一的位置重合结果不等于0，而合理的状态进行同样的按位与运算后结果为0，因此可以利用这一点首先枚举出所有合理的状态，在对这些合理的状态进行状态转移会节省很多时间。</li>
<li>其次是看某合理状态是否满足地形限制，假设平原为0、高地为1，那么PHHP即表示$(0110)_2$也就是6，合理的状态应为高地处不能放炮兵只能为0，平原处可以放也可以不放即0、1均可，那么该地形状态与合理的状态相与结果为0，否则该炮兵放置不符合地形限制。</li>
<li>再者即是不同行的限制，某行的状态与其前两行的状态不能冲突，也就是对应位置不能同时出现1，这个状态的限制很明了了，也就是相与之后为0即合理，若不为0即说明对应位置同时有1，那么炮兵会打到自己人，不合理！</li>
<li>状态转移，由于判断某一行状态是否满足时需要知道其前两行的状态，因此需要需要枚举第i-2、i-1、i行的状态来进行转移，用dp[i][j][k]表示第i行状态为j第i-1行状态为k时最大炮兵数，那么转移方程可以写为dp[i][j][k]=max（dp[i][j][k],dp[i-1][k][h]+num[j]）,其中h为i-2行的状态，num[j]为状态j的炮兵数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">			<span class="comment">//printf(&quot;%c\n&quot;,c);</span></span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">&#x27;H&#x27;</span>) mp[i]=mp[i]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> mp[i]=mp[i]*<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tot=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=i;</span><br><span class="line">		<span class="keyword">while</span>(tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			num[i]+=(tmp&amp;<span class="number">1</span>);</span><br><span class="line">			tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((i&amp;(i&lt;&lt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">2</span>)))<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(mp[<span class="number">1</span>]&amp;i) <span class="keyword">continue</span>;</span><br><span class="line">		dp[<span class="number">1</span>][i][<span class="number">0</span>]=num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((j&amp;(j&lt;&lt;<span class="number">1</span>))||(j&amp;(j&lt;&lt;<span class="number">2</span>)))<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(mp[i]&amp;j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=tot;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((k&amp;(k&lt;&lt;<span class="number">1</span>))||(k&amp;(k&lt;&lt;<span class="number">2</span>)))<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(mp[i<span class="number">-1</span>]&amp;k) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(j&amp;k) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;=tot;h++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>((h&amp;(h&lt;&lt;<span class="number">1</span>))||(h&amp;(h&lt;&lt;<span class="number">2</span>)))<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(mp[i<span class="number">-2</span>]&amp;h) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(k&amp;h) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(j&amp;h) <span class="keyword">continue</span>;</span><br><span class="line">					dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i<span class="number">-1</span>][k][h]+num[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,dp[n][i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式合并</title>
    <url>/2021/09/28/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“启发式合并在合并的时候确实挺启发我的！”</font></center>
</blockquote>
<span id="more"></span>
<p>启发式合并的大致思想是：合并的时候每次总是将小的集合往大的集合进行合并，这样时间复杂度会减小许多，但是如果采用一般的数组结构，当小集合的每个元素往大集合中插入时一个一个比较而找出适当的位置，这样的线性复杂度也是不可接受的，故应该采用优先队列的数据结构，那么插入的时间复杂度降为O（log N）,因此当需要合并操作时可以优先考虑启发式合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a.t&lt;b.t;<span class="comment">//时间大的在优先队列的首部</span></span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; Q[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">char</span> c,c1,c2;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> ccnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(Q[a].<span class="built_in">size</span>()) Q[a].<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">while</span>(Q[b].<span class="built_in">size</span>()) Q[b].<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++ccnt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cs=<span class="number">1</span>;cs&lt;=n;cs++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s &quot;</span>,s);</span><br><span class="line">			<span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">				<span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Q[a].<span class="built_in">top</span>().val);</span><br><span class="line">					Q[a].<span class="built_in">pop</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Q[b].<span class="built_in">top</span>().val);</span><br><span class="line">					Q[b].<span class="built_in">pop</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>,&amp;c,&amp;x);</span><br><span class="line">				<span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) Q[a].<span class="built_in">push</span>(&#123;cnt++,x&#125;);</span><br><span class="line">				<span class="keyword">else</span> Q[b].<span class="built_in">push</span>(&#123;cnt++,x&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>,&amp;c1,&amp;c2);</span><br><span class="line">				<span class="comment">//总是将B栈合并至A栈，但是若A栈的大小比B栈小，交换a、b的值，保证小栈合并至大栈</span></span><br><span class="line">				<span class="keyword">if</span>(Q[a].<span class="built_in">size</span>()&lt;Q[b].<span class="built_in">size</span>()) <span class="built_in">swap</span>(a,b);</span><br><span class="line">				<span class="keyword">while</span>(Q[b].<span class="built_in">size</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					Q[a].<span class="built_in">push</span>(Q[b].<span class="built_in">top</span>());</span><br><span class="line">					Q[b].<span class="built_in">pop</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(c1==<span class="string">&#x27;B&#x27;</span>) <span class="built_in">swap</span>(a,b);<span class="comment">//每次合并都是合并至A栈，若输入要求合并至B栈，则交换a、b的值即可</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2021/09/06/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“盖亚！”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。<br>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
<p>构造差分序列，$b_1=a_1,b_2=a_2-a_1 … b_n=a_n-a_n-1,b_(n+1)=0$，使得原序列的值均相等即是差分序列$b_2$至$b_n$的值为0，而每次选取选取区间[l,r]对其进行加1或减1也就是对$b_l$和$b_(r+1)$进行一加一减的操作，而内部的差分值不会改变，因此对任意区间进行此操作即为对任意两个点进行一加一减或一减一加的操作，利用这个特点可以统计出差分序列正值的和的绝对值p与负值的和的绝对值q，有正有负的情形下首选对两个点一加一减的操作，这样可以使操作次数最少，次数为$min(p,q)$,剩下只有正数或负数的情形，可以选择对b1与其中某点进行操作或对$b_(n+1)$与其中某点操作，操作次数为$|p-q|$,故总次数为$|p-q|+min(p,q)=max(p,q)$,值得注意的是前一步的操作不会改变$b_1即a_1$的值，后一步的操作可以选择性的对$a_1$的值进行更改0至|p-q|次，故$a_1$的结果会有$|p-q|+1$种结果，那们最终相同的序列亦会有$|p-q|+1$种情形。<br><a href="https://www.acwing.com/problem/content/102/">acwing-100</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll posi=<span class="number">0</span>;</span><br><span class="line">    ll nega=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        posi+=(b[i]&gt;<span class="number">0</span>)?b[i]:<span class="number">0</span>;</span><br><span class="line">        nega+=(b[i]&lt;<span class="number">0</span>)?b[i]:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=posi;</span><br><span class="line">    ll q=<span class="built_in">abs</span>(nega);</span><br><span class="line">    ll ans=<span class="built_in">max</span>(p,q);</span><br><span class="line">    ll res=<span class="built_in">abs</span>(p-q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n%lld\n&quot;</span>,ans,res+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>差分</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>约数</title>
    <url>/2021/11/06/%E6%9C%80%E5%B0%8F%E5%BC%82%E6%88%96%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“XOR-MST”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="最大-小异或对"><a href="#最大-小异或对" class="headerlink" title="最大/小异或对"></a>最大/小异或对</h2><p>问：​ 在给定的n个整数里选出两个数进行异或运算，得到的结果最小是多少？</p>
<p>思路：枚举第一个数x，在字典树中找与第一个数异或值最小的数（按位比较，若x此时为1，为了异或最小那么应该找1，没有1便只能找0，如此找下去，该值即与x异或值最小），然后再与最终结果取min。（最大同理）</p>
<h2 id="最小异或生成树"><a href="#最小异或生成树" class="headerlink" title="最小异或生成树"></a>最小异或生成树</h2><p>题意：给定一个点，每个点都有一个价值，任意连个点的边权值为该两个点的价值的异或值，求最小生成树的值。</p>
<ul>
<li><p>若给出你一个数 例如是x时那么与x相连的y要是x^y最小那么，x和y的二进制除了最后一位不一样剩下的都一样这样才最小，最小为1.如果x没有对应的除了二进制最后一位不一样其他都一样的，就往前面推一位，不断地扩大代价尝试。这样保证代价最小。之后是让最后两位不一样…………以此类推因为这样才能保证最后的异或和最小。</p>
</li>
<li><p>现给定一个由五个数建成的01字典树,那么根据上面的规则，4一定跟5匹配就是我上面说的，从最后一位往前推看是否除了该位其他二进制位都一样，显然4有5作伴，而6最后一位没有匹配的，所以往前推一位那就是4跟他异或最小（这里体现的不是很明显，因为6往前推的时候4、5都满足条件，但是进过验证才知道4 xor 6比5 xor 6更小）。<br><a href="%E6%9C%80%E5%B0%8F%E5%BC%82%E6%88%96%E7%94%9F%E6%88%90%E6%A0%91/2.png">ok</a></p>
</li>
<li><p>下面给出一个更清晰的例子，若给出你2 ，3，5, 6四个数求这四个数的最小异或生成树，首先看2，根据上面说的他就是跟3匹配。然后看5,没有4，那么我们继续往上推没有7，接下来我们应该推最后一位 因为这样的代价只是2+1，而你要是再往前推得话他就是4所以我们要从小代价开始。所以就是6，因为生成树他是通路，所以2-3 和5-6 还差一条边也就是左树和右树合并最小。所以就得出这个分治思想：一个节点下的最小异或生成树 = 左子树自己连接 + 右子树连接 + 左右合并时产生的最小值。重点就是左右合并是产生的最小值，合并时的最小值的求法同上面最小异或对的求法。<br><a href="%E6%9C%80%E5%B0%8F%E5%BC%82%E6%88%96%E7%94%9F%E6%88%90%E6%A0%91/3.png">ok</a><br><a href="https://codeforces.com/contest/888/problem/G">CF - G</a><br>参考链接：<a href="https://blog.csdn.net/weixin_45911397/article/details/107671083">link</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e7</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">10007</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> t=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>((ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)t=<span class="literal">true</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)x=x*<span class="number">10</span>+ch<span class="number">-48</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> t?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">ll a[maxn],n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//标记结点 就是记录第几个结点。这个就是字典树中的结点那个 </span></span><br><span class="line">	<span class="keyword">int</span> trie[maxn][<span class="number">2</span>];<span class="comment">//01字典树 </span></span><br><span class="line">	<span class="keyword">int</span> l[maxn],r[maxn];<span class="comment">//l 是最小用到这个结点的第几条边  r[]最大用到这个结点的第几条边 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">inint</span><span class="params">()</span></span>&#123;<span class="comment">//初始化 cnt=0； 就是返回根节点从头开始 </span></span><br><span class="line">		cnt=<span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//构建01字典树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x,<span class="keyword">int</span> id)</span></span>&#123;<span class="comment">// x代表插入这个数 ，id代表第几个数 </span></span><br><span class="line">		<span class="keyword">int</span> gen=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">///从2进制最高位开始依次往下构建01字典树 </span></span><br><span class="line">			<span class="keyword">int</span> op =(x&gt;&gt;i&amp;<span class="number">1ll</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//判断这个x在该二进制位上是0还是1这样形成他的分叉 相当于 (x&gt;&gt;i)%2 也就是 判断他是左子树还是右子树 就是把x转化成2进制然后利用字典树从上往下排下来 </span></span><br><span class="line">			<span class="keyword">if</span>(!trie[gen][op])trie[gen][op]=++cnt;<span class="comment">//如果这个几点没用过就创建出来，并且标记出来他的节点号，也就是第几个节点 </span></span><br><span class="line">			gen=trie[gen][op];<span class="comment">//然后走他的下一位 换句话说 就是走 这个根节点的 下一个节点。</span></span><br><span class="line">			<span class="keyword">if</span>(!l[gen]) l[gen]=id;<span class="comment">//如果在此之前(x)没有任何数 有过该位的经历 说简单点就是这些数中没有比他小的且该位是op的。</span></span><br><span class="line">			r[gen]=id;<span class="comment">//一直更新最大使用这个的， </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">answer</span><span class="params">(<span class="keyword">int</span> gen,<span class="keyword">int</span> pos,ll x)</span></span>&#123;<span class="comment">//gen代表第几位也就是 二进制的从头开始第几位，pos是从第几位开始计算 ，x是这个数 </span></span><br><span class="line">		ll ans=<span class="number">0</span>;<span class="comment">//初始值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从pos开始往后遍历每一位 看每一位是否有对应的左右结点 </span></span><br><span class="line">			<span class="keyword">int</span> op=(x&gt;&gt;i&amp;<span class="number">1ll</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//分出x的i位2进制的01；</span></span><br><span class="line">			<span class="keyword">if</span>(trie[gen][op]) gen=trie[gen][op];<span class="comment">//如果右端点有对应的 子树（对应的0或1）就直接看下一层</span></span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//没有对应的 </span></span><br><span class="line">				gen=trie[gen][!op];<span class="comment">//跟有对应的节点只能用另一节点来代替这时就会产生代价(1&lt;&lt;i),</span></span><br><span class="line">				ans+=(<span class="number">1ll</span>&lt;&lt;i);<span class="comment">//第i为产生代价 就加上该代价，之所以 是从pos 开始到0 是因为这样的话都可以选择最优 因为 i越大产生的代价就越大 所以尽量的让其前面的一致这样就会缩小代价 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">div</span><span class="params">(<span class="keyword">int</span> gen,<span class="keyword">int</span> pos)</span></span>&#123;<span class="comment">//gen 和pos 跟上面解释一样 </span></span><br><span class="line">		<span class="keyword">if</span>(trie[gen][<span class="number">0</span>]&amp;&amp;trie[gen][<span class="number">1</span>])&#123;<span class="comment">//如果既有左又有右   这一步就是左+右+合并 </span></span><br><span class="line">			<span class="keyword">int</span> x=trie[gen][<span class="number">0</span>],y=trie[gen][<span class="number">1</span>];<span class="comment">///x代表 左端点的结点号，y代表右端点的节点号，x&lt;y这是一定的 因为我们原本排序了 </span></span><br><span class="line">			ll minn=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=l[x];i&lt;=r[x];i++)&#123;<span class="comment">//枚举左子树中从小到大的数 </span></span><br><span class="line">				minn=<span class="built_in">min</span>(minn,<span class="built_in">answer</span>(y,pos<span class="number">-1</span>,a[i])+(<span class="number">1</span>&lt;&lt;pos)); <span class="comment">//解释一下 answer(y,pos-1,a[i])+(1&lt;&lt;pos)  前面pos-1是看pos之后那些代价。而（1&lt;&lt;pos） 则是该位产生的代价 因为合并 你判断出这位是一个0和一个1 就一定会产生这个代价 （求最小异或对，便于后面面两棵子树的合并）</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> minn+<span class="built_in">div</span>(trie[gen][<span class="number">0</span>],pos<span class="number">-1</span>)+<span class="built_in">div</span>(trie[gen][<span class="number">1</span>],pos<span class="number">-1</span>);  <span class="comment">//合并+ 左+右  </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(trie[gen][<span class="number">0</span>]) <span class="keyword">return</span> <span class="built_in">div</span>(trie[gen][<span class="number">0</span>],pos<span class="number">-1</span>);<span class="comment">//如果只有左就直接是左 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(trie[gen][<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">div</span>(trie[gen][<span class="number">1</span>],pos<span class="number">-1</span>);<span class="comment">//如果只有右就直接是右 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果都没有，肯定是0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read read()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	trie.<span class="built_in">inint</span>();<span class="comment">//初始化 </span></span><br><span class="line">   	<span class="built_in">sf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">sf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) trie.<span class="built_in">insert</span>(a[i],i);</span><br><span class="line">    <span class="comment">///tire.Traceback(0);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,trie.<span class="built_in">div</span>(<span class="number">0</span>,<span class="number">32</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>异或</tag>
        <tag>最小生成树</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2022/02/08/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="汉诺塔问题分析"><a href="#汉诺塔问题分析" class="headerlink" title="汉诺塔问题分析"></a>汉诺塔问题分析</h2><p><img src="/images/loading.png" data-original="/2022/02/08/%E6%B1%89%E8%AF%BA%E5%A1%94/%E6%B1%89%E8%AF%BA%E5%A1%94.png" alt="汉诺塔"><br>1个盘子：直接移动， “N==1”是递归终结条件。<br>N个盘子：吧移动N个盘子的问题转化为移动N-1盘子的问题。<br>递归解决：<br>(1)把A上面的N-1个盘子移动B（借助C）；<br>(2)把第N个盘子一道C；<br>(3)把B上的N-1个盘子移到C（借助A）<br>结论：n个盘子需要移动2^n-1次便能转移完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hannuo</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> src,<span class="keyword">int</span> tmp,<span class="keyword">int</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		cout&lt;&lt;src&lt;&lt;<span class="string">&quot;------&gt;&quot;</span>&lt;&lt;dst&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">hannuo</span>( num<span class="number">-1</span>, src,dst,tmp);</span><br><span class="line">	    cout&lt;&lt;src&lt;&lt;<span class="string">&quot;------&gt;&quot;</span>&lt;&lt;dst&lt;&lt;endl;</span><br><span class="line">	    cnt++;</span><br><span class="line">	    <span class="built_in">hannuo</span>( num<span class="number">-1</span>, tmp, src, dst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">hannuo</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>汉诺塔</category>
      </categories>
      <tags>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>日常笔记</title>
    <url>/2022/01/07/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="质数的大致数量范围"><a href="#质数的大致数量范围" class="headerlink" title="质数的大致数量范围"></a>质数的大致数量范围</h2><ul>
<li>50000以内的质数共5133个</li>
</ul>
<h2 id="闰年的判断"><a href="#闰年的判断" class="headerlink" title="闰年的判断"></a>闰年的判断</h2><ul>
<li>整百年（世纪年）要整除四百</li>
<li>非整百年（世纪年）只需整除4即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((year%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;year%<span class="number">4</span>==<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="平方数规律"><a href="#平方数规律" class="headerlink" title="平方数规律"></a>平方数规律</h2><p>对于任意四个连续的数：$a,b,c,d$，则有$d^2+a^2-b^2-c^2=4$，如$1^2+4^2-2^2-3^2=4$。</p>
<h2 id="平方和公式"><a href="#平方和公式" class="headerlink" title="平方和公式"></a>平方和公式</h2><p>$ \sum _{i=1}^{n}i^2=n∗(n+1)∗(2*n+1)/6$</p>
<h2 id="约数个数（涨知识啦）"><a href="#约数个数（涨知识啦）" class="headerlink" title="约数个数（涨知识啦）"></a>约数个数（涨知识啦）</h2><ul>
<li><p>对于任意一个数W，他的约数个数是多少？假设W的质因子分解式是$W=a1^{p1}+a2^{p2}+……+an^{pn}$（a1…an均为质因子）,那么W的约数个数就是**(p1+1)*(p2+1)*……*(pn+1)**。</p>
</li>
<li><p><a href="https://www.lanqiao.cn/problems/806/learning/">序列求和</a>:现已知约数个数n，求最小的具有n个约数的数$S_n$是是多少,求$S_1+…+S_{60}$？</p>
<ul>
<li>将n进行质因数分解$n=(p_1+1)<em>(p_2+1)</em>…(p_n+1)$,那么$p_1…p_n$即为$S_n$质因数分解后的质因子的指数，要保证X最小，那么只需要从最小的质数开始选择即可。如n=4,$4=(1+1)<em>(1+1)$,那么$S_4=2^1</em>3^1=6$。</li>
<li>故需要对n进行因式分解取其中使得$S_n$最小的情形，一开始认为每次取最小的因子将n分解，这样每一个指数就会越小，但同样质因子的个数会增加（如$24=2<em>2</em>2<em>3$ | $24=4</em>3*2$，此时取后一种情形更加），因此不能盲目的贪心，那么就只能通过搜索暴力求解了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,mid,num&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,r,num&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="keyword">bool</span> ppp[<span class="number">5000010</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll base,ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll an=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&amp;<span class="number">1</span>) an=an*base;</span><br><span class="line">        num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        base=base*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> an;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ppp[i])</span><br><span class="line">            prime.<span class="built_in">pb</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;prime.<span class="built_in">size</span>()&amp;&amp;i*prime[j]&lt;=num;j++)</span><br><span class="line">            ppp[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">6</span>];</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">ll res[<span class="number">61</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> coun=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        coun*=(k[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(coun&gt;<span class="number">60</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(k[i]&gt;k[i<span class="number">-1</span>]) <span class="keyword">return</span>;</span><br><span class="line">    ll sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        sum*=<span class="built_in">qpow</span>(prime[i],k[i]);</span><br><span class="line">    res[coun]=<span class="built_in">min</span>(res[coun],sum);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k[i]++;</span><br><span class="line">        <span class="built_in">dfs</span>();</span><br><span class="line">        k[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_prime</span>(<span class="number">16</span>);</span><br><span class="line">    k[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) res[i]=<span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">dfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">60</span>;i++)</span><br><span class="line">        ans+=res[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>约数</title>
    <url>/2021/09/07/%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<center><font size="4">“搬山鹧鸪哨！”</font></center>
</blockquote>
<span id="more"></span>
<h2 id="求1-N每个数的正因子的集合或数目"><a href="#求1-N每个数的正因子的集合或数目" class="headerlink" title="求1-N每个数的正因子的集合或数目"></a>求1-N每个数的正因子的集合或数目</h2><p>用平常的“试除法”可以解，但是会有O(n $\sqrt{n}$)的时间复杂度，因此可以考虑更精妙的算法“倍数法”，主要思想为：对于一个数d，若1-N中某个数的因子包含d，则其必是d的倍数，利用这一思想可以在O（nlog（n））的时间复杂度求出结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正因子数目</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line">ll yz[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n,i,j,cnt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n/i;j++)<span class="comment">//枚举倍数，但是某个因子乘以倍数不超过N</span></span><br><span class="line">        &#123;</span><br><span class="line">            yz[i*j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有正因子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//cin.sync_with_stdio(false);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;<span class="comment">//数量级为1e9</span></span><br><span class="line">ll yz[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; factor[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,cnt;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n/i;j++)<span class="comment">//枚举倍数，但是某个因子乘以倍数不超过N</span></span><br><span class="line">        &#123;</span><br><span class="line">            factor[i*j].<span class="built_in">push_back</span>(i);<span class="comment">//i*j这个数的因子包含i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>约数</category>
      </categories>
      <tags>
        <tag>约数</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯训练</title>
    <url>/2022/02/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="垒骰子"><a href="#垒骰子" class="headerlink" title="垒骰子"></a>垒骰子</h2><ul>
<li>题意：赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。<br>经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！<br>我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。<br>假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。<br>atm想计算一下有多少种不同的可能的垒骰子方式。<br>两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。<br>由于方案数可能过多，请输出模 10^9 + 7 的结果。</li>
<li>输入：n，m（0&lt; n &lt;=1e9）</li>
<li>思路：通过设置最底层的初始状态，通过状态转移求得最终层的合理方案数。</li>
<li>状态定义dp[i][j]：在第i层顶层显示数字j的方案数，这里比较坑的地方时骰子可以旋转，也就是说在顶层数字确定的情况下会有四个方向也就是四种情况。而且骰子的数目也非常大，但是发现后一层的状态只与前一层的状态有关，因此可以用到滚动数组，但是值得注意的是在更新下一层的数据时记得进行初始化！</li>
<li>枚举该层骰子的顶面数与下一层骰子的底面数，判断是否会出现相斥，进行状态转移即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> opp[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	opp[<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">	opp[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">	opp[<span class="number">2</span>]=<span class="number">5</span>;</span><br><span class="line">	opp[<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line">	opp[<span class="number">3</span>]=<span class="number">6</span>;</span><br><span class="line">	opp[<span class="number">6</span>]=<span class="number">3</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		mp[x][y]=<span class="number">1</span>;</span><br><span class="line">		mp[y][x]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll dp[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++) dp[<span class="number">1</span>][i]=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=<span class="number">6</span>;p++) dp[(i+<span class="number">1</span>)%<span class="number">2</span>][p]=<span class="number">0</span>;<span class="comment">//滚动数组再用到下一层数据时记得清零</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!mp[j][k]) </span><br><span class="line">				&#123;</span><br><span class="line">					dp[(i+<span class="number">1</span>)%<span class="number">2</span>][opp[k]]=(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][opp[k]]+<span class="number">4</span>*dp[i%<span class="number">2</span>][j]%mod)%mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;dp[n][i]&lt;&lt;endl;</span></span><br><span class="line">		res=(res+dp[n%<span class="number">2</span>][i])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四平方和问题"><a href="#四平方和问题" class="headerlink" title="四平方和问题"></a>四平方和问题</h2></li>
</ul>
<p>题意：给定n，必定存在n=a * a+b * b+c * c+d * d,按照升序给出a，b，c，d的值</p>
<ul>
<li>思路：按照一般的思路，四个循环分别枚举a，b，c，d即可，但是显然时间复杂度不允许；因此可以分开计算a * a+b * b 与 c * c+d * d，这样时间复杂度大大降低。</li>
<li>方法：先求出所有可能的a * a+b * b的值存入map中，此时再枚举c，d，查看map中有无map[n-a * a-b * b]即可，存在即输出，不存在就跳过往下找。</li>
</ul>
<h2 id="剪邮票"><a href="#剪邮票" class="headerlink" title="剪邮票"></a>剪邮票</h2><p>题意：<img src="/images/loading.png" data-original="/2022/02/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83/blog\betblog\source_posts\蓝桥杯训练\剪邮票.png" alt="image-20220407102341084"></p>
<ul>
<li>思路：由于数据量并不是很大，因此可以想到枚举检验的方式，那么便需要从12个数中任意选取5个数所有的方案中进行验证，并判断这五个数是否连续即可；从12个数中任取5个的枚举方式可以选择next_permutation()函数，先在数组中从小到大存储7个0以及5个1，这时候在这12个数进行全排列的过程中即能够覆盖所有选取五个数的情况，这时候在进行验证即可；验证可以采取判断是否只有一个连通通块的方式验证，枚举12个起始点，从标记为1的数字开始dfs，将搜到的点标记为0，跑完之后cnt++，即得到一个连通块，最后判断连通块的个数即可。</li>
</ul>
<h2 id="包子凑数（扩展欧几里得）"><a href="#包子凑数（扩展欧几里得）" class="headerlink" title="包子凑数（扩展欧几里得）"></a>包子凑数（扩展欧几里得）</h2><ul>
<li>题意：给定n个数，每个数都有任意个，问是否有可能让这些数任意组合使得只有有限个数这些数不能构成，如果能的话输出不能组成的数的个数，否则便会有无穷多个无法组成的数，输出INF即可。（1=&lt; N,$x_i$ &lt;=100）</li>
<li>思路：该n个数能够组成的数的表达式如下：$num=a_1 * x_1 + a_2 * x_2 + … + a_n * x_n$,跟据扩展欧几里得原理，该方程式有解的情况即为$num=k*gcd(x_1 … x_n)$,也就是说改n个数能够构成的数只要 k * gcd(x1,x2,…,xn),因此要想该n个数能够构成任意数，也就只有当gcd=1时才可能实现。</li>
<li>故当gcd！=1时会有无穷多个数无法构成，输出INF；当gcd=1时，虽然理论上能够构成任意数，但是当初始值x1 … xn足够大num很小时虽然有解但也是负数解与这里的实际情况不符，因此需要特殊考虑，考虑到100个xi的范围最多也是10000，那么就特殊考虑10000以内的数这n个数能够构成的数的情况即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="comment">// int mp[N];</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	<span class="keyword">int</span> gcd;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		x=a[i];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) gcd=x;</span><br><span class="line">		<span class="keyword">else</span> gcd=__gcd(gcd,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(gcd!=<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;INF\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10000</span>;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mp[j])</span><br><span class="line">				&#123;</span><br><span class="line">					mp[j+a[i]]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++) <span class="keyword">if</span>(!mp[i]) ans++;</span><br><span class="line">			cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出现奇数次的数"><a href="#出现奇数次的数" class="headerlink" title="出现奇数次的数"></a>出现奇数次的数</h2>题意：给定n个数，其中只有一个数的出现次数为奇数次，其余的数均出现偶数次，求该出现奇数次的数是多少？</li>
<li>思路：结合异或操作的特性知道：<ul>
<li>偶数个x进行异或其值为0</li>
<li>奇数个x进行异或其值为x</li>
<li>异或操作满足交换律</li>
</ul>
</li>
<li>那么知道，如果将这n个值进行异或操作后，那么偶数次的数全部异或成0了，只剩下出现奇数次的数，也就是答案。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		ans^=x;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="心的形状"><a href="#心的形状" class="headerlink" title="心的形状"></a>心的形状</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//输出空格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//输出*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==n) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;* &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> deep=(n+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=deep;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print1</span>((n+<span class="number">1</span>)/<span class="number">2</span>-(i<span class="number">-1</span>)*<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">print2</span>(<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">print1</span>(<span class="number">4</span>*deep<span class="number">-1</span><span class="number">-4</span>*(i<span class="number">-1</span>));</span><br><span class="line">		<span class="built_in">print2</span>(<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">print1</span>(i);</span><br><span class="line">		<span class="built_in">print2</span>(n-i+<span class="number">1</span>);</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="简单却很难"><a href="#简单却很难" class="headerlink" title="简单却很难"></a>简单却很难</h2><ul>
<li>题意：给定a,b,c，求$a^{b^c}mod p$,(a,b,b&lt;=$10^9$，p为质数)</li>
<li>提示：没错，题目就是这么简单明了，而且明确告诉你需要用到费马小定理（$a^{p-1} mod p=1$），你确定会吗？</li>
<li>思路：题目的意图也就是求$b^{c}$个a相乘然后模p，由费马小定理可知$a^{p-1}$ mod p 等于1,因此可以从$b^c$中分出所有的p-1,该部分模p等于1不影响答案，那么答案就在剩余部分的幂模p，即$a^{b^{c}%(p-1)}  % p$。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qsm</span><span class="params">(ll a,ll k,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=(ll)res*a%p;</span><br><span class="line">		a=(ll)a*a%p;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	ll a,b,c;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">	ll z=<span class="built_in">qsm</span>(b,c,p<span class="number">-1</span>);</span><br><span class="line">	ll y=<span class="built_in">qsm</span>(a,z,p);</span><br><span class="line">	cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 818398173 491423852 785451404</span></span><br><span class="line"><span class="comment">// 751968174</span></span><br></pre></td></tr></table></figure>
<h2 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a><a href="https://www.lanqiao.cn/problems/544/learning/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NDQyODI2MDIsImciOiJKcEs2VFFxNndjS1dXM1QzIiwiaWF0IjoxNjQ0MjgyMzAyLCJ1c2VySWQiOi0xNzM1MTUxNTcyfQ.4vWw1lb87P6kq3ghFvbUhJ4X99djkvE6bbE5RWW8wBE">删除字符</a></h2></li>
<li>题目：给定一个单词，请问在单词中删除 t 个字母后，能得到的字典序最小的单词是什么？<br></li>
<li>思路：从前往后看每一个字母，如果后面有更小的字典序字母，那么说明该字母可以被删除以得到更小字典序的字符串，反之则说明该处的字母已经是最小字典序，那么不用删除往后扫描即可，如果删除次数最终没有用完，那么从后往前删除对应个数的字母即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;str[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                str.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="货物摆放"><a href="#货物摆放" class="headerlink" title="货物摆放"></a>货物摆放</h2><ul>
<li>题意：现有n个货物，需要在长、宽、高的方向上分别堆 L、W、H 的货物,满足 n=L×W×H,问当n=2021041820210418（16位数），有多少种摆放方式？</li>
<li>思路一：<br>暴力枚举三个因子，如果不考虑三个因子的排列来统计次数需要分别对三个因子进行1e^16 的枚举，显然时间复杂度上是不允许的。那么转换思路，通过设置枚举方式使得枚举出的因子L&lt;=W&lt;=H,这样第一个因子只需枚举至$^{3}\sqrt{n}$大概$1e^5$的位置,在往上枚举会出现L&gt;W&gt;H的局面，即会出现重复计算，最后通过三者的相等关系来统计方案数（L=W=H：方案数++；L=W!=H:方案数+3；L!=W!=H:方案数+6）。</li>
<li>注：虽然时间复杂度大幅降低，但是运算出结果任然需要一定的时间，不满足时限要求。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n=<span class="number">2021041820210418</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(n%i) <span class="keyword">continue</span>;</span><br><span class="line">    	<span class="keyword">for</span>(ll j=i;i*j*j&lt;=n;j++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(n / i %j==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			ll k=n/i/j;</span><br><span class="line">    			<span class="keyword">if</span>(i==j==k) ans++;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i==j||j==k||i==k) ans+=<span class="number">3</span>;</span><br><span class="line">    			<span class="keyword">else</span> ans+=<span class="number">6</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路二：<br><br>求出所有的正因子，在所有因子中枚举L、W、H，找出合适的方案(该题中2021041820210418的因子只有128个)。</li>
<li>有感：<br><br>一个这么大的数，其因子才128个，因此在一些分解问题上，可以考虑利用$\sqrt{n}$的试除法来求出所有的因子并进行枚举！<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">vector&lt;ll&gt; v; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n=<span class="number">2021041820210418</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(n%i==<span class="number">0</span>) </span><br><span class="line">    	&#123;</span><br><span class="line">    		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    		ll k=n/i;</span><br><span class="line">    		<span class="keyword">if</span>(k!=i) v.<span class="built_in">push_back</span>(k);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:v)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> b:v)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">auto</span> c:v)</span><br><span class="line">	    	&#123;</span><br><span class="line">	    		<span class="keyword">if</span>(a*b*c==n) ans++;</span><br><span class="line">	    	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><ul>
<li>题意：小蓝准备用 256MB256MB 的内存空间开一个数组，数组的每个元素都是 3232 位 二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问 256MB256MB 的空间可以存储多少个 3232 位二进制整数？</li>
<li>思路：1B=8bit，直接计算就行。</li>
<li>注意：1024默认位int型，1024 * 1024 * 256 *8会超出int型范围，所以需要类型强制转换。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">vector&lt;ll&gt; v; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int范围内的整数默认为int型</span></span><br><span class="line">	<span class="comment">//int 范围外的整数默认为long long</span></span><br><span class="line">	ll ans=<span class="number">1024LL</span>*<span class="number">1024</span>*<span class="number">256</span>*<span class="number">8</span>;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最少砝码"><a href="#最少砝码" class="headerlink" title="最少砝码"></a>最少砝码</h2><ul>
<li>题意：你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意 小于等于 N 的正整数重量，那么这套砝码最少需要包含多少个砝码？（注意砝码可以放在天平两边。）</li>
<li>思路：先写出前面几个的数所需最小砝码数，从而找出规律如下：<br><br>1     所需砝码    1 （3^0）<br><br>2-4   所需砝码    2 （3^1）<br><br>5-13  所需砝码    3 （3^2）<br><br>由此看出是一个等比数列，根据对用的N以及前n项和即可算出所需砝码数。<br>即$s_n=(3^n-1)/2 &gt; N$,可得n=$log_3(2*N+1)$（向上取整）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">ceil</span>(<span class="built_in">log10</span>(<span class="number">2</span>*n+<span class="number">1</span>)/<span class="built_in">log10</span>(<span class="number">3</span>))&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找-2020"><a href="#寻找-2020" class="headerlink" title="寻找 2020"></a>寻找 2020</h2><ul>
<li>[题面]（<a href="https://www.lanqiao.cn/problems/1065/learning/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NDQzNzM0NDEsImciOiJKcEs2VFFxNndjS1dXM1QzIiwiaWF0IjoxNjQ0MzczMTQxLCJ1c2VySWQiOi0xNzQxMDU5OTYxfQ.MK2NK26tG5drVFZO647aYoquWHR-jXzc1Js8n5vCKYU%EF%BC%89">https://www.lanqiao.cn/problems/1065/learning/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NDQzNzM0NDEsImciOiJKcEs2VFFxNndjS1dXM1QzIiwiaWF0IjoxNjQ0MzczMTQxLCJ1c2VySWQiOi0xNzQxMDU5OTYxfQ.MK2NK26tG5drVFZO647aYoquWHR-jXzc1Js8n5vCKYU）</a></li>
<li>题意：在给定的0 2 矩阵中找到共有多少个横向、纵向、以及斜向的’2020’。</li>
<li>思路：对于矩阵中的每一个位置向右、向下、斜向下寻找2020，找到即答案加1.</li>
<li>特殊处理：对于矩阵每行向后增加三个空字符，并在最后面增加三行空字符。这样每个字符向右、向下、斜向下寻找三个字符时不需要进行越界判断。</li>
<li>注意：值得一提的是填空题没有输入，直接输出结果，否则会报运行错误！！！<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;s&amp;&amp;s!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    s+=<span class="string">&quot;   &quot;</span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">s2</span><span class="params">(<span class="number">310</span>,<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(s2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">300</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">300</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(v[i][j]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i][j+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;v[i][j+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i][j+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>) ans++;</span><br><span class="line">      <span class="keyword">if</span>(v[i][j]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i+<span class="number">1</span>][j]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;v[i+<span class="number">2</span>][j]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i+<span class="number">3</span>][j]==<span class="string">&#x27;0&#x27;</span>) ans++;</span><br><span class="line">      <span class="keyword">if</span>(v[i][j]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;v[i+<span class="number">2</span>][j+<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;v[i+<span class="number">2</span>][j+<span class="number">3</span>]==<span class="string">&#x27;0&#x27;</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子串分值和"><a href="#子串分值和" class="headerlink" title="子串分值和"></a>子串分值和</h2><p>题意：给定一个字符串s，定义f（s）为s中出现的不同的字符个数，求一个给定字符串s的所有子串y的f(y)之和。<br>思路：</p>
<ul>
<li>由于子串的构造具有规律性与继承性，因此可以先写出前几个子串寻找规律；</li>
<li>对于字符串”ababc”来说，其子串有：<br>a<br>ab b<br>aba ba a<br>abab abb ab b<br>ababc babc abc bc c<br>由此可以看出，每新增一个字符都是在前面的子串基础上增加一个字符，因此可以得到递推公式dp[i]=dp[i-1]+新增贡献量，不难发现新增的贡献量即为该字符与该字符上一次出现的位置的距离，于是可以求出答案。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100010</span>],last[<span class="number">100010</span>],tmp[<span class="number">30</span>];</span><br><span class="line">ll dp[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">  <span class="comment">//求出字符串每个字符上一次所出现的位置</span></span><br><span class="line">	<span class="built_in">memset</span>(tmp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pre[i]=tmp[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		tmp[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//求出字符串每个字符下一次所出现的位置</span></span><br><span class="line">	<span class="comment">// memset(tmp,s.size(),sizeof(tmp));</span></span><br><span class="line">	<span class="comment">// for(int i=0;i&lt;s.size();i++)</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	last[i]=tmp[s[i]-&#x27;a&#x27;];</span></span><br><span class="line">	<span class="comment">// 	tmp[s[i]-&#x27;a&#x27;]=i;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+(ll)(i-pre[i]);</span><br><span class="line">		ans+=dp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="平面切分"><a href="#平面切分" class="headerlink" title="平面切分"></a>平面切分</h2><ul>
<li>题意：平面上有n条直线，其中第i条直线是$y=a_i*x+b_i$,请计算这些直线将平面分成了几个部分。</li>
<li>思路：根据小范围的数据推算可以知道，每新增一条直线所新增平面数与形成的不同交点数有关，若存在n个不同的交点，那么便会新增n+1个平面，由此只需要计算后溪加入的直线与之前的不同交点个数便可以得到答案。</li>
<li>数据结构：<ul>
<li>交点坐标用pair&lt;double,double&gt;键值对来存储</li>
<li>交点坐标的去重通过set&lt;pair&lt;double,double&gt; &gt;来实现</li>
</ul>
</li>
<li>注意：<ul>
<li>可能会有重复的直线，重复的直线不会新增平面数</li>
<li>对于重复直线判断过后还需判断平行直线与相交直线，否则会漏掉情况<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDD pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">100010</span>],b[<span class="number">10010</span>],k[<span class="number">10010</span>];</span><br><span class="line">set&lt;PDD&gt; s;</span><br><span class="line">PDD p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        k[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> aa=a[i];</span><br><span class="line">        <span class="keyword">double</span> bb=b[i];</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k[i]==k[j]&amp;&amp;b[i]==b[j]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;<span class="comment">//注意考虑所有的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k[i]==k[j]) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p.first=(b[j]-bb)/(aa-a[j]);</span><br><span class="line">                p.second=(aa*b[j]-a[j]*bb)/(aa-a[j]);</span><br><span class="line">                s.<span class="built_in">insert</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>) &#123;s.<span class="built_in">clear</span>();<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(s.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">clear</span>();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>题意：给定n个加号、m个减号以及N+M+1个整数A1,A2,···,A(n+m+1),小明想知道在所有由这N个加号、M个减号以及N+M+1个整数凑出的合法的后缀表达式中，结果最大的是哪一个？</p>
<ul>
<li>思路：本来以为是简单的贪心，排序后加上n+1个大数减去m个小数即为答案，但是实际上如果是中缀表达式那么是这样没错，但是实际上是可以通过加上括号更改计算顺序从而尽可能多的消耗掉减号使答案最大，比如：a-（b-c-d-f-g）（假设都为正数），这样只需要减去一个b即可，那么处理的时候只需要减去最小值即可。</li>
<li>上面也提到了负数结合上减号会对结果有影响，而正数不会，因此需要对负数的个数进行分类：<ol>
<li>没有负数：只需将其他数相加减去最小值接口（若减号为0则不用减）</li>
<li>有负数：<ul>
<li>负数个数小于减号数目：一个负数消耗掉一个减号，多余的减号通过括号让正数添加至负数之后来消耗，这样正数不会是结果减小，如a-（b-c-d-e）（b为负数，c，d，e均为正数）</li>
<li>负数个数大于减号数目：负数从小到大消耗减号即可</li>
</ul>
</li>
</ol>
</li>
<li>注意：以下的方法为先求和再根据时间情况加上或减去应有的数值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	k=n+m+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m+<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		ans+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+<span class="number">1</span>+n+m);</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m) ans-=<span class="number">2</span>*a[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k&amp;&amp;a[i]&lt;<span class="number">0</span>&amp;&amp;m&gt;<span class="number">0</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans-=a[i]*<span class="number">2</span>;</span><br><span class="line">			m--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="递增三元组"><a href="#递增三元组" class="headerlink" title="递增三元组"></a>递增三元组</h2><ul>
<li>题意：给定三个整数数组A，B，C，每个数组均有N个数，请你统计有多少个三元组(i, j, k) 满足：<br>　　1. 1 &lt;= i, j, k &lt;= N<br>　　2. Ai &lt; Bj &lt; Ck<br>（1 &lt;= N &lt;= 100000 0 &lt;= Ai, Bi, Ci &lt;= 100000）</li>
<li>思路一：<br>分别找出A中小于每一个Bi的个数Xi，再找出C中大于于每一个Bi的个数Si,那么对于每一个i，$X_i$*$S_i$之和就是答案。</li>
<li>实现一：看似需要$n^2$的时间复杂度来实现该要求，但实际上通过排序后结合双指针就能够通过$o(N)$的时间复杂度算出上述结果。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],b[<span class="number">100010</span>],c[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i,j,n;</span><br><span class="line">	ll count=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">	<span class="built_in">sort</span>(b,b+n);</span><br><span class="line">	<span class="built_in">sort</span>(c,c+n);</span><br><span class="line">	i=n<span class="number">-1</span>;</span><br><span class="line">	j=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;b[j])<span class="comment">//如果a[i]&lt;b[j]那么a[i]之前的树也全部小于b[j],那么a中小于b[j]的数目有i+1个（下标从0开始）</span></span><br><span class="line">		&#123;</span><br><span class="line">			x[j]=i+<span class="number">1</span>;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i--;</span><br><span class="line">	&#125;</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[i]&lt;c[j])<span class="comment">//如果b[i]&lt;c[j]那么a[i]之后的数也全部大于b[j],那么a中小于b[j]的数目有n-i个（下标从0开始）</span></span><br><span class="line">		&#123;</span><br><span class="line">			count+=(ll)x[i]*(n-j);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j++;</span><br><span class="line">		</span><br><span class="line">	&#125;	 </span><br><span class="line">	cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>蓝桥杯训练</category>
      </categories>
      <tags>
        <tag>蓝桥杯训练</tag>
      </tags>
  </entry>
  <entry>
    <title>点分治</title>
    <url>/2021/11/26/%E7%82%B9%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="点分治前置知识"><a href="#点分治前置知识" class="headerlink" title="点分治前置知识"></a>点分治前置知识</h2><ol>
<li><p>点分治的基本思想</p>
<pre><code> 点分治，顾名思义就是基于树上的节点进行分治。

 如果我们在深入一点呢？对于点的拆开其实就是对于树的拆开。

 所以我认为点分治的本质其实是将一棵树拆分成许多棵子树处理，并不断进行。

 这应该也是点分治的精髓。
</code></pre>
</li>
<li><p>分治点的选择</p>
<pre><code> 既然我们要将一个点进行分治，那么选点肯定最首要的。

 思考下面一个问题：

 如果树退化为一个链，我们选取链首作为分治点，理论时间复杂度？

 而如果选择链的中心，它的理论时间复杂度又是多少？

 答案其实还是挺简单的。

 选择链首：O( n )

 选择链心：O( logn )

 通过这个例子,我们不难发现：

 如果选点后左右子树越大，递归层数越多，时间越慢，反之则越快。

 所以我们的选点标准就出来了，而我们把有这个性质的点叫做：树的重心！
</code></pre>
</li>
</ol>
<h2 id="重心"><a href="#重心" class="headerlink" title="重心"></a>重心</h2><ul>
<li>重心的性质及证明：<a href="https://www.cnblogs.com/suxxsfe/p/13543253.html">大佬的博客</a></li>
</ul>
<ol>
<li>树的重心如果不唯一，则至多有两个，且这两个重心相邻</li>
</ol>
<ul>
<li><p>先假设有两个重心 u,v 不相邻，考虑它们之间的这条路径，则至少有三个节点（以下的 “它们之间的路径” 都是指 u,v 之间的路径）</p>
</li>
<li><p>设 u 的不包含它们之间的这条路径的若干子树中（就是有一个子树是以它们路径上与 u 相邻的那个点为根的，先排除那个子树），最小的子树大小是 sizeu，则 v 的包含它们路径的那个子树的大小为 sizeu+k,k≥2。那么这个子树不能是 u 的大小最大的子树，否则 v 的这个包含它们之间的路径的子树，大小比它还大，v 就不是重心了</p>
</li>
<li><p>对 v 进行相同的分析，得到同样结论</p>
</li>
<li><p>那么 u,v 最大的子树就只能分别是包含它们之间路径的那个子树，假设从它们之间的路径上（不包含它们）的点，延伸出去的点的个数为 size（这个 size 已经把路径上的点算上了），则它们这个最大的子树的大小就分别是 v,u 的不包含它们之间路径的子树的大小和，加 size+1，又因为它们都是重心，最大子树都最小，则上面所述的这个 “v,u 的不包含它们之间路径的子树的大小和” 应该相等，设其为 size′</p>
</li>
<li><p>但是发现，若从它们之间的路径上（不包含它们本身）取一点，则这个点沿着它们之间路径的两个子树应该都小于 size′+size+1，而其他子树显然都小于 size′，那么 u,v 都不是重心，矛盾</p>
</li>
<li><p>则重心必须相邻，又因为这是一个树，所以最多只有两个点相邻，最多两个重心.</p>
</li>
</ul>
<ol start="2">
<li>一个点是重心，等价于，以这个点为根，它的每个子树的大小，都不会超过整个树大小的一半</li>
</ol>
<ul>
<li><p>假设重心是 u，它的一个子树大小超过整个树大小的一半，设这个子树的根是 v（与 u 相邻）</p>
</li>
<li><p>用 sizei 表示以 i 为根的子树大小，则 sizev&gt;sizeu2</p>
</li>
<li><p>那么，u 除了子树 v 以外的其它所有子树（把 u 本身也计算在内）的大小是 $size_u−size_v$</p>
</li>
<li><p>所以，如果以 v 为重心，则它的一个子树是 sizeu−sizev，这个子树就是以 u 为根的那个。$size_u−size_v&lt;size_v$，此时，v “往上”的那个以 u 为根的子树小于 u 的最大子树大小，而其他“往下”的子树显然也小于，所以可以说明，也说明如果以 v 为重心，最大子树的大小小于以 u 为根最大子树的大小，则矛盾。得证</p>
</li>
<li><p>再来推若每个子树都不超过整个树的一半，那么一定是重心</p>
</li>
<li><p>设这个每个子树都不超过整个树一半的节点为 u，重心为 v，考虑 u,v 之间的路径<br>v 总会有一个子树包含 u，（就是包含它们之间路径的那一个），从而包含了，u 的除了包含这它们之间路径的那个子树，的所有其他子树，由于 u 任意子树大小小于总体的一半，所以 v 的这个子树，也就是 u 的剩余所有子树，大小 ≥sizeu2</p>
</li>
<li><p>那么显然 v 不是重心，矛盾。这样，对于任意的 v≠u，都不是重心，则 u 是重心（当然可能存在一个相邻的点，使得它们都有一个等于整体一半的子树，那么就是有两个重心的情况）</p>
</li>
<li><p>则也就顺带着说明了，只有在总点数为偶数时，才可能会出现有两个重心的情况，这两个重心相邻，且都只有两个子树，大小分别为 num2,num2−1</p>
</li>
</ul>
<ol start="3">
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的。如果有两个重心，那么到它们的距离和一样。更进一步，距离和最小与是重心等价</li>
</ol>
<ul>
<li><p>一开始想大力推式子然后反证法证明，结果推了半天发现好像假了</p>
</li>
<li><p>实际上应该是用调整法</p>
</li>
<li><p>就是先假设当前选择一个点 u，然后看我们把选择的点调整到一个与 u 相邻的点，看能不能使得距离和更小</p>
</li>
<li><p>什么样的点能满足上面的性质？那就是以它为根的子树大小大于以 u 为根的大小的一半的点，这样让那些其他子树的一共小于一半的点多走 1，让这大于一半的点少走 1，总体少走了</p>
</li>
<li><p>直到所有相邻节点为根的子树都小于当前的 u 的一半，那么无论往哪个点上再进行移动，都只会使距离和更大，而这样的点，就是重心，得证</p>
</li>
</ul>
<ol start="4">
<li>如果一个树增添，或删去一个叶子，则整个树的同一个重心最多移动一个节点</li>
</ol>
<ul>
<li><p>如果是增加节点，那么如果需要移动的话，则是沿着重心和新增的节点之间的路径来移动，这种情况肯定是因为新增节点使得包含它们之间路径的那个子树过大（大于整个树的一半，根据第二条性质）。而往那移动一位，就会让这个子树减少的大小大于等于一，那么就又小于等于了这个树的一半，又由于树最多有两个重心且我们讨论的是“同一个重心”的移动，所以移动一次就够了，移动更多就又不是重心了</p>
</li>
<li><p>如果是删除节点，删除以后导致包含被删除的节点的子树大小减小，那么其他子树可能就大于整个树大小的一半了。则重心往这个子树上移动一位，至于为什么只移动一位，和上面的分析相似</p>
</li>
</ul>
<ol start="5">
<li>通过连接一条端点分别在两个树的边，来将两个树合并成一个，那么新的重心肯定是在原来这两个树的重心的路径上</li>
</ol>
<ul>
<li><p>不妨假设连接的两个点就是两个树原来的根</p>
</li>
<li><p>然后可以发现，仍然可以用一种不断调整的方法，假设原先两个重心分别是 u,v，从 u 开始调整，当目前仍在 u 所在的原先的那颗树中时，肯定是朝着根调整，因为是根那个方向被接入了另一个树导致大小变大</p>
</li>
<li><p>如果还没调整到原先的根，就符合了最大子树小于等于总结点数一半的条件，自然符合性质，这就说明了，如果新重心在原来 u 所在的那个子树上的话，一定在 u 到它原来的根的路径上</p>
</li>
<li><p>同理可以说明，如果新重心在 v 所在的那个子树上，一定在 u 到它原来那个根的路径上<br>把这两个合起来就是本条性质了</p>
</li>
</ul>
<h2 id="点分治入门"><a href="#点分治入门" class="headerlink" title="点分治入门"></a>点分治入门</h2><ul>
<li>题意：给定一棵带权树，求出树上长度小于等于k的路径树。</li>
</ul>
<p>Solution：</p>
<ul>
<li><p>选定树上一个点，那么树上所有的路径可以分为进过该点的路径和不经过该点的路径，那么便可以对该点进行<strong>点分治</strong>。那么应该选取哪个点呢？在了解了重心的概念及作用后便应该明白应该选择重心来作为分治点。</p>
</li>
<li><p>在选取分治点后应该分开求两种路径满足条件的有多少条路径。经过该点的路径求法：求出所有子树中的点到该分治点的距离d，用数组d保存，而经过该点的路径即为从任意两棵子树中选取某条路径进行拼接。这里可以用到树状数组记录个长度路径的条数，当求出一棵子树的所有路径后去树状数组中查找路径&lt;=k-d[i]的路径树即getsum(k-d[i])，此时再将这棵子树的路径信息插入树状数组，对于该分治点的所有子树按顺序进行上述过程能够不重复的统计出所有路径信息。</p>
</li>
<li><p>需要注意的是当对其子树统计答案时树状数组的值应该重置，将其中直接全部置为0复杂度为o（数组长度），当子树较多时重置次数也随之上升，可能超出时限。因此可以通过再进行一次dfs扫描出上述的所有路径（因为求子树中所有点到分治点的距离也是跑一遍dfs），将其值-1更新，这样复杂度最多只有o（n（点的个数））。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> n,K,cnt=<span class="number">0</span>,rt;<span class="comment">//rt全局变量记录重心</span></span><br><span class="line"><span class="keyword">int</span> tree[MAXN],sz[MAXN],d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,w;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;v=a;w=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; adj[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=K)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[x]+=k;</span><br><span class="line">		x+=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=tree[x];</span><br><span class="line">		x-=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_rt</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> tot)</span><span class="comment">//dfs求重心</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_rt</span>(v,u,tot);</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">		maxn=<span class="built_in">max</span>(maxn,sz[v]);<span class="comment">//记录最大子树的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	maxn=<span class="built_in">max</span>(maxn,tot-sz[u]);<span class="comment">//因为是无根树，前面的子树也应该算进去取最大值</span></span><br><span class="line">	<span class="keyword">if</span>(maxn*<span class="number">2</span>&lt;=tot) rt=u;<span class="comment">//最大子树大小（点的数目）不超过tot/2即为重心</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_sz</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//分治之后需要重新求一遍子树的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_sz</span>(v,u);</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> dis)</span><span class="comment">//记录该子树所有点到分支点的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d[++cnt]=dis;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">int</span> w=adj[u][i].w;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_dis</span>(v,u,dis+w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_clear</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> dis)</span><span class="comment">//清空树状数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dis) <span class="built_in">update</span>(dis,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">int</span> w=adj[u][i].w;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_clear</span>(v,u,dis+w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tot)</span><span class="comment">//点分治</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,v,w;</span><br><span class="line">	<span class="built_in">dfs_rt</span>(u,<span class="number">0</span>,tot);<span class="comment">//找重心</span></span><br><span class="line">	u=rt;<span class="comment">//重心的值赋值给u，使变量统一</span></span><br><span class="line">	vis[u]=<span class="number">1</span>;<span class="comment">//将分治点进行标记，也相当于设置边界，分治之后不能再遍历分治点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v=adj[u][i].v;</span><br><span class="line">		w=adj[u][i].w;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs_dis</span>(v,u,w);<span class="comment">//遍历该子树，d数组存下该子树所有点到该分治点的距离</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)<span class="comment">//统计答案</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[i]&lt;=K) ans++;</span><br><span class="line">			ans+=<span class="built_in">getsum</span>(<span class="built_in">max</span>(<span class="number">0</span>,K-d[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)<span class="comment">//更新树状数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(d[i],<span class="number">1</span>);<span class="comment">//长度为d[i]的路径条数+1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs_clear</span>(u,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//清空</span></span><br><span class="line">    <span class="built_in">dfs_sz</span>(u,<span class="number">0</span>);<span class="comment">//以重心为根，跑出所有点的子树大小</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"> 		ans+=<span class="built_in">divide</span>(v,sz[v]);<span class="comment">//递归求子树中的答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		adj[u].<span class="built_in">push_back</span>(edge&#123;v,w&#125;);</span><br><span class="line">		adj[v].<span class="built_in">push_back</span>(edge&#123;u,w&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;K;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">divide</span>(<span class="number">1</span>,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="点分治-树形dp"><a href="#点分治-树形dp" class="headerlink" title="点分治+树形dp"></a>点分治+树形dp</h2><ul>
<li>题意：给定一棵n个点的树，每个点都有一个权值，求出所有连通子图的权值和在[1 - m]之间的权值和。</li>
</ul>
<p>Solution</p>
<ul>
<li>此题m值较小，可以利用bitset的性质快速维护权值和的信息。</li>
<li>对于每一个点来说，该树上的联通子图可以分为包含该点的联通子图和不包含该点的联通子图，因此可以想到选取该树的重心作为分治点进行分治。</li>
<li>对于每个分治点u来说，dp[u]表示包含点u的非联通子图的权值和，dp[u]|=dp[v]（v为u的邻接点，此时dp[v]表示既包含点u又包含点v的所有非联通子图的权值和，因为前提是求的包含点u的非联通子图的权值和）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSUM=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">int</span> n,m,rt,sz[MAXN],val[MAXN],d[MAXN],cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">bitset&lt;MAXSUM&gt; ans,dp[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,w;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;v=a;w=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; adj[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[u].<span class="built_in">push_back</span>(edge&#123;v,<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_rt</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_rt</span>(v,u,tot);</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">		maxn=<span class="built_in">max</span>(sz[v],maxn);</span><br><span class="line">	&#125;</span><br><span class="line">	maxn=<span class="built_in">max</span>(maxn,tot-sz[u]);</span><br><span class="line">	<span class="keyword">if</span>(maxn*<span class="number">2</span>&lt;=tot) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_sz</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_sz</span>(v,u);</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span>求包含点u的非联通子图的权值和</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u]&lt;&lt;=val[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		dp[v]=dp[u];<span class="comment">//复制父节点的权值和信息</span></span><br><span class="line">		<span class="built_in">solve</span>(v,u);</span><br><span class="line">		dp[u]|=dp[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">dfs_rt</span>(u,<span class="number">0</span>,tot);</span><br><span class="line">	u=rt;</span><br><span class="line">	vis[u]=<span class="number">1</span>;<span class="comment">//用完分治点之后将该点标记并丢掉</span></span><br><span class="line">	dp[u].<span class="built_in">reset</span>();</span><br><span class="line">	dp[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(u,<span class="number">0</span>);</span><br><span class="line">	ans|=dp[u];<span class="comment">//包含点u的连通子图的所有权值和加入ans</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs_sz</span>(u,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=adj[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">divide</span>(v,sz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t,u,v;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">		ans.<span class="built_in">reset</span>();</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			<span class="built_in">add</span>(u,v);</span><br><span class="line">			<span class="built_in">add</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class="line">		<span class="built_in">divide</span>(<span class="number">1</span>,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;ans[i];</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) adj[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">6 10</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">1 3 5 7 9 11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 10</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">3 2 7 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
</search>
